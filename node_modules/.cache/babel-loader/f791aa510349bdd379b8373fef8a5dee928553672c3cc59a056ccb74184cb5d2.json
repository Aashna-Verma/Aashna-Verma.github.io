{"ast":null,"code":"function t() {\n  return t = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (t[s] = i[s]);\n    }\n    return t;\n  }, t.apply(this, arguments);\n}\nfunction e(t, e, i) {\n  return Math.max(t, Math.min(e, i));\n}\nclass i {\n  advance(t) {\n    var i;\n    if (!this.isRunning) return;\n    let s = !1;\n    if (this.lerp) this.value = (o = this.value, n = this.to, (1 - (l = 1 - Math.exp(-60 * this.lerp * t))) * o + l * n), Math.round(this.value) === this.to && (this.value = this.to, s = !0);else {\n      this.currentTime += t;\n      const i = e(0, this.currentTime / this.duration, 1);\n      s = i >= 1;\n      const o = s ? 1 : this.easing(i);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var o, n, l;\n    null == (i = this.onUpdate) || i.call(this, this.value, s), s && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, e, {\n    lerp: i = .1,\n    duration: s = 1,\n    easing: o = t => t,\n    onStart: n,\n    onUpdate: l\n  }) {\n    this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, null == n || n(), this.onUpdate = l;\n  }\n}\nclass s {\n  constructor({\n    wrapper: t,\n    content: e,\n    autoResize: i = !0\n  } = {}) {\n    if (this.resize = () => {\n      this.onWrapperResize(), this.onContentResize();\n    }, this.onWrapperResize = () => {\n      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n    }, this.onContentResize = () => {\n      this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n    }, this.wrapper = t, this.content = e, i) {\n      const t = function (t, e) {\n        let i;\n        return function () {\n          let e = arguments,\n            s = this;\n          clearTimeout(i), i = setTimeout(function () {\n            t.apply(s, e);\n          }, 250);\n        };\n      }(this.resize);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var t, e;\n    null == (t = this.wrapperResizeObserver) || t.disconnect(), null == (e = this.contentResizeObserver) || e.disconnect();\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass o {\n  constructor() {\n    this.events = {};\n  }\n  emit(t, ...e) {\n    let i = this.events[t] || [];\n    for (let t = 0, s = i.length; t < s; t++) i[t](...e);\n  }\n  on(t, e) {\n    var i;\n    return (null == (i = this.events[t]) ? void 0 : i.push(e)) || (this.events[t] = [e]), () => {\n      var i;\n      this.events[t] = null == (i = this.events[t]) ? void 0 : i.filter(t => e !== t);\n    };\n  }\n  off(t, e) {\n    var i;\n    this.events[t] = null == (i = this.events[t]) ? void 0 : i.filter(t => e !== t);\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass n {\n  constructor(t, {\n    wheelMultiplier: i = 1,\n    touchMultiplier: s = 2,\n    normalizeWheel: n = !1\n  }) {\n    this.onTouchStart = t => {\n      const {\n        clientX: e,\n        clientY: i\n      } = t.targetTouches ? t.targetTouches[0] : t;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n    }, this.onTouchMove = t => {\n      const {\n          clientX: e,\n          clientY: i\n        } = t.targetTouches ? t.targetTouches[0] : t,\n        s = -(e - this.touchStart.x) * this.touchMultiplier,\n        o = -(i - this.touchStart.y) * this.touchMultiplier;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: s,\n        y: o\n      }, this.emitter.emit(\"scroll\", {\n        deltaX: s,\n        deltaY: o,\n        event: t\n      });\n    }, this.onTouchEnd = t => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event: t\n      });\n    }, this.onWheel = t => {\n      let {\n        deltaX: i,\n        deltaY: s\n      } = t;\n      this.normalizeWheel && (i = e(-100, i, 100), s = e(-100, s, 100)), i *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n        deltaX: i,\n        deltaY: s,\n        event: t\n      });\n    }, this.element = t, this.wheelMultiplier = i, this.touchMultiplier = s, this.normalizeWheel = n, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new o(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n}\nclass l {\n  constructor({\n    wrapper: e = window,\n    content: l = document.documentElement,\n    wheelEventsTarget: r = e,\n    eventsTarget: h = r,\n    smoothWheel: a = !0,\n    smoothTouch: c = !1,\n    syncTouch: u = !1,\n    syncTouchLerp: p = .1,\n    __iosNoInertiaSyncTouchLerp: d = .4,\n    touchInertiaMultiplier: m = 35,\n    duration: v,\n    easing: g = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: S = !v && .1,\n    infinite: w = !1,\n    orientation: f = \"vertical\",\n    gestureOrientation: y = \"vertical\",\n    touchMultiplier: T = 1,\n    wheelMultiplier: z = 1,\n    normalizeWheel: _ = !1,\n    autoResize: M = !0\n  } = {}) {\n    this.onVirtualScroll = ({\n      deltaX: e,\n      deltaY: i,\n      event: s\n    }) => {\n      if (s.ctrlKey) return;\n      const o = s.type.includes(\"touch\"),\n        n = s.type.includes(\"wheel\");\n      if (\"both\" === this.options.gestureOrientation && 0 === e && 0 === i || \"vertical\" === this.options.gestureOrientation && 0 === i || \"horizontal\" === this.options.gestureOrientation && 0 === e || o && \"vertical\" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && i <= 0) return;\n      let l = s.composedPath();\n      if (l = l.slice(0, l.indexOf(this.rootElement)), l.find(t => {\n        var e;\n        return (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent\")) || o && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-touch\")) || n && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-wheel\")) || (null == (e = t.classList) ? void 0 : e.contains(\"lenis\"));\n      })) return;\n      if (this.isStopped || this.isLocked) return void s.preventDefault();\n      if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && o || this.options.smoothWheel && n, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n      s.preventDefault();\n      let r = i;\n      \"both\" === this.options.gestureOrientation ? r = Math.abs(i) > Math.abs(e) ? i : e : \"horizontal\" === this.options.gestureOrientation && (r = e);\n      const h = o && this.options.syncTouch,\n        a = o && \"touchend\" === s.type && Math.abs(r) > 1;\n      a && (r = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + r, t({\n        programmatic: !1\n      }, h && {\n        lerp: a ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp\n      }));\n    }, this.onNativeScroll = () => {\n      if (!this.__preventNextScrollEvent && !this.isScrolling) {\n        const t = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n      }\n    }, window.lenisVersion = \"1.0.29\", e !== document.documentElement && e !== document.body || (e = window), this.options = {\n      wrapper: e,\n      content: l,\n      wheelEventsTarget: r,\n      eventsTarget: h,\n      smoothWheel: a,\n      smoothTouch: c,\n      syncTouch: u,\n      syncTouchLerp: p,\n      __iosNoInertiaSyncTouchLerp: d,\n      touchInertiaMultiplier: m,\n      duration: v,\n      easing: g,\n      lerp: S,\n      infinite: w,\n      gestureOrientation: y,\n      orientation: f,\n      touchMultiplier: T,\n      wheelMultiplier: z,\n      normalizeWheel: _,\n      autoResize: M\n    }, this.animate = new i(), this.emitter = new o(), this.dimensions = new s({\n      wrapper: e,\n      content: l,\n      autoResize: M\n    }), this.toggleClass(\"lenis\", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = u || a || c, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll = new n(h, {\n      touchMultiplier: T,\n      wheelMultiplier: z,\n      normalizeWheel: _\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass(\"lenis\", !1), this.toggleClass(\"lenis-smooth\", !1), this.toggleClass(\"lenis-scrolling\", !1), this.toggleClass(\"lenis-stopped\", !1), this.toggleClass(\"lenis-locked\", !1);\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  off(t, e) {\n    return this.emitter.off(t, e);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const e = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * e);\n  }\n  scrollTo(t, {\n    offset: i = 0,\n    immediate: s = !1,\n    lock: o = !1,\n    duration: n = this.options.duration,\n    easing: l = this.options.easing,\n    lerp: r = !n && this.options.lerp,\n    onComplete: h = null,\n    force: a = !1,\n    programmatic: c = !0\n  } = {}) {\n    if (!this.isStopped && !this.isLocked || a) {\n      if ([\"top\", \"left\", \"start\"].includes(t)) t = 0;else if ([\"bottom\", \"right\", \"end\"].includes(t)) t = this.limit;else {\n        var u;\n        let e;\n        if (\"string\" == typeof t ? e = document.querySelector(t) : null != (u = t) && u.nodeType && (e = t), e) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            i -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = e.getBoundingClientRect();\n          t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof t) {\n        if (t += i, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = e(0, t, this.limit), s) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), void (null == h || h(this));\n        if (!c) {\n          if (t === this.targetScroll) return;\n          this.targetScroll = t;\n        }\n        this.animate.fromTo(this.animatedScroll, t, {\n          duration: n,\n          easing: l,\n          lerp: r,\n          onStart: () => {\n            o && (this.isLocked = !0), this.isScrolling = !0;\n          },\n          onUpdate: (t, e) => {\n            this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), null == h || h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {\n              delete this.__preventNextScrollEvent;\n            }));\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;\n    var t;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClass(\"lenis-smooth\", t));\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClass(\"lenis-scrolling\", t));\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.__isStopped = t, this.toggleClass(\"lenis-stopped\", t));\n  }\n  get isLocked() {\n    return this.__isLocked;\n  }\n  set isLocked(t) {\n    this.__isLocked !== t && (this.__isLocked = t, this.toggleClass(\"lenis-locked\", t));\n  }\n  get className() {\n    let t = \"lenis\";\n    return this.isStopped && (t += \" lenis-stopped\"), this.isLocked && (t += \" lenis-locked\"), this.isScrolling && (t += \" lenis-scrolling\"), this.isSmooth && (t += \" lenis-smooth\"), t;\n  }\n  toggleClass(t, e) {\n    this.rootElement.classList.toggle(t, e), this.emitter.emit(\"className change\", this);\n  }\n}\nexport { l as default };","map":{"version":3,"names":["e","t","i","Math","max","min","advance","isRunning","s","lerp","value","o","n","to","l","exp","round","currentTime","duration","easing","from","onUpdate","call","stop","fromTo","onStart","constructor","wrapper","content","autoResize","resize","onWrapperResize","onContentResize","window","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","arguments","clearTimeout","setTimeout","apply","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","limit","x","y","events","emit","length","on","push","filter","off","wheelMultiplier","touchMultiplier","normalizeWheel","onTouchStart","clientX","clientY","targetTouches","touchStart","lastDelta","onTouchMove","emitter","deltaX","deltaY","event","onTouchEnd","onWheel","element","addEventListener","passive","removeEventListener","document","documentElement","wheelEventsTarget","r","eventsTarget","h","smoothWheel","a","smoothTouch","c","syncTouch","u","syncTouchLerp","p","__iosNoInertiaSyncTouchLerp","d","touchInertiaMultiplier","m","v","g","pow","S","infinite","w","orientation","f","gestureOrientation","T","z","_","M","onVirtualScroll","ctrlKey","type","includes","options","scroll","composedPath","slice","indexOf","rootElement","find","hasAttribute","classList","contains","isStopped","isLocked","preventDefault","isSmooth","isScrolling","animate","abs","velocity","scrollTo","targetScroll","programmatic","onNativeScroll","__preventNextScrollEvent","animatedScroll","actualScroll","direction","sign","lenisVersion","body","dimensions","toggleClass","virtualScroll","setScroll","isHorizontal","scrollLeft","scrollTop","reset","start","raf","time","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","requestAnimationFrame","progress","__isSmooth","__isScrolling","__isStopped","__isLocked","className","toggle","default"],"sources":["C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\maths.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\animate.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\dimensions.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\debounce.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\emitter.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\virtual-scroll.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(\r\n    from,\r\n    to,\r\n    { lerp = 0.1, duration = 1, easing = (t) => t, onStart, onUpdate }\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\nexport class Dimensions {\r\n  constructor({ wrapper, content, autoResize = true } = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      const resize = debounce(this.resize, 250)\r\n\r\n      if (this.wrapper !== window) {\r\n        this.wrapperResizeObserver = new ResizeObserver(resize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(resize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    this.scrollHeight = this.content.scrollHeight\r\n    this.scrollWidth = this.content.scrollWidth\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event, ...args) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event, cb) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  off(event, callback) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport { clamp } from './maths'\r\n\r\nexport class VirtualScroll {\r\n  constructor(\r\n    element,\r\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n    this.normalizeWheel = normalizeWheel\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\r\n    this.element.addEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event) => {\r\n    let { deltaX, deltaY } = event\r\n\r\n    if (this.normalizeWheel) {\r\n      deltaX = clamp(-100, deltaX, 100)\r\n      deltaY = clamp(-100, deltaY, 100)\r\n    }\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n}\r\n","import { version } from '../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\nexport default class Lenis {\r\n  // isScrolling = true when scroll is animating\r\n  // isStopped = true if user should not be able to scroll - enable/disable programmatically\r\n  // isSmooth = true if scroll should be animated\r\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\r\n\r\n  /**\r\n   * @typedef {(t: number) => number} EasingFunction\r\n   * @typedef {'vertical' | 'horizontal'} Orientation\r\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\r\n   *\r\n   * @typedef LenisOptions\r\n   * @property {Window | HTMLElement} [wrapper]\r\n   * @property {HTMLElement} [content]\r\n   * @property {Window | HTMLElement} [wheelEventsTarget] // deprecated\r\n   * @property {Window | HTMLElement} [eventsTarget]\r\n   * @property {boolean} [smoothWheel]\r\n   * @property {boolean} [smoothTouch]\r\n   * @property {boolean} [syncTouch]\r\n   * @property {number} [syncTouchLerp]\r\n   * @property {number} [__iosNoInertiaSyncTouchLerp]\r\n   * @property {number} [touchInertiaMultiplier]\r\n   * @property {number} [duration]\r\n   * @property {EasingFunction} [easing]\r\n   * @property {number} [lerp]\r\n   * @property {boolean} [infinite]\r\n   * @property {Orientation} [orientation]\r\n   * @property {GestureOrientation} [gestureOrientation]\r\n   * @property {number} [touchMultiplier]\r\n   * @property {number} [wheelMultiplier]\r\n   * @property {boolean} [normalizeWheel]\r\n   * @property {boolean} [autoResize]\r\n   *\r\n   * @param {LenisOptions}\r\n   */\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper, // deprecated\r\n    eventsTarget = wheelEventsTarget,\r\n    smoothWheel = true,\r\n    smoothTouch = false,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.1,\r\n    __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = !duration && 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    normalizeWheel = false,\r\n    autoResize = true,\r\n  } = {}) {\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (wrapper === document.documentElement || wrapper === document.body) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      eventsTarget,\r\n      smoothWheel,\r\n      smoothTouch,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      __iosNoInertiaSyncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n      autoResize,\r\n    }\r\n\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    this.toggleClass('lenis', true)\r\n\r\n    this.velocity = 0\r\n    this.isLocked = false\r\n    this.isStopped = false\r\n    this.isSmooth = syncTouch || smoothWheel || smoothTouch\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener('scroll', this.onNativeScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.toggleClass('lenis', false)\r\n    this.toggleClass('lenis-smooth', false)\r\n    this.toggleClass('lenis-scrolling', false)\r\n    this.toggleClass('lenis-stopped', false)\r\n    this.toggleClass('lenis-locked', false)\r\n  }\r\n\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event, callback) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  setScroll(scroll) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  onVirtualScroll = ({ deltaX, deltaY, event }) => {\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    if (\r\n      (this.options.gestureOrientation === 'both' &&\r\n        deltaX === 0 &&\r\n        deltaY === 0) || // \"touchend\" events prevents \"click\"\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) || // trackpad previous/next page gesture\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0) ||\r\n      (isTouch &&\r\n        this.options.gestureOrientation === 'vertical' &&\r\n        this.scroll === 0 &&\r\n        !this.options.infinite &&\r\n        deltaY <= 0) // touch pull to refresh\r\n    )\r\n      return\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node.hasAttribute?.('data-lenis-prevent') ||\r\n          (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n          (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n          node.classList?.contains('lenis') // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault()\r\n      return\r\n    }\r\n\r\n    this.isSmooth =\r\n      ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!this.isSmooth) {\r\n      this.isScrolling = false\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 1\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch && {\r\n        lerp: hasTouchInertia\r\n          ? this.syncTouchLerp\r\n          : this.options.__iosNoInertiaSyncTouchLerp,\r\n      }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  onNativeScroll = () => {\r\n    if (this.__preventNextScrollEvent) return\r\n\r\n    if (!this.isScrolling) {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.velocity = 0\r\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\r\n      this.emit()\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.animatedScroll = this.targetScroll = this.actualScroll\r\n    this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = !duration && this.options.lerp,\r\n      onComplete = null,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n    } = {}\r\n  ) {\r\n    if ((this.isStopped || this.isLocked) && !force) return\r\n\r\n    // keywords\r\n    if (['top', 'left', 'start'].includes(target)) {\r\n      target = 0\r\n    } else if (['bottom', 'right', 'end'].includes(target)) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      onComplete?.(this)\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      if (target === this.targetScroll) return\r\n\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onStart: () => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = true\r\n      },\r\n      onUpdate: (value, completed) => {\r\n        this.isScrolling = true\r\n\r\n        // updated\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity)\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        if (!completed) this.emit()\r\n\r\n        if (completed) {\r\n          this.reset()\r\n          this.emit()\r\n          onComplete?.(this)\r\n\r\n          // avoid emitting event twice\r\n          this.__preventNextScrollEvent = true\r\n          requestAnimationFrame(() => {\r\n            delete this.__preventNextScrollEvent\r\n          })\r\n        }\r\n      },\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return this.options.wrapper === window\r\n      ? document.documentElement\r\n      : this.options.wrapper\r\n  }\r\n\r\n  get limit() {\r\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll() {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll() {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress() {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.__isSmooth\r\n  }\r\n\r\n  set isSmooth(value) {\r\n    if (this.__isSmooth !== value) {\r\n      this.__isSmooth = value\r\n      this.toggleClass('lenis-smooth', value)\r\n    }\r\n  }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  set isScrolling(value) {\r\n    if (this.__isScrolling !== value) {\r\n      this.__isScrolling = value\r\n      this.toggleClass('lenis-scrolling', value)\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  set isStopped(value) {\r\n    if (this.__isStopped !== value) {\r\n      this.__isStopped = value\r\n      this.toggleClass('lenis-stopped', value)\r\n    }\r\n  }\r\n\r\n  get isLocked() {\r\n    return this.__isLocked\r\n  }\r\n\r\n  set isLocked(value) {\r\n    if (this.__isLocked !== value) {\r\n      this.__isLocked = value\r\n      this.toggleClass('lenis-locked', value)\r\n    }\r\n  }\r\n\r\n  get className() {\r\n    let className = 'lenis'\r\n    if (this.isStopped) className += ' lenis-stopped'\r\n    if (this.isLocked) className += ' lenis-locked'\r\n    if (this.isScrolling) className += ' lenis-scrolling'\r\n    if (this.isSmooth) className += ' lenis-smooth'\r\n    return className\r\n  }\r\n\r\n  toggleClass(name, value) {\r\n    this.rootElement.classList.toggle(name, value)\r\n    this.emitter.emit('className change', this)\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
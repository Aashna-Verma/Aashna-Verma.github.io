{"ast":null,"code":"function t() {\n  return t = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i = arguments[e];\n      for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (t[s] = i[s]);\n    }\n    return t;\n  }, t.apply(this, arguments);\n}\nfunction e(t, e, i) {\n  return Math.max(t, Math.min(e, i));\n}\nclass i {\n  advance(t) {\n    var i;\n    if (!this.isRunning) return;\n    let s = !1;\n    if (this.lerp) this.value = (o = this.value, n = this.to, (1 - (l = 1 - Math.exp(-60 * this.lerp * t))) * o + l * n), Math.round(this.value) === this.to && (this.value = this.to, s = !0);else {\n      this.currentTime += t;\n      const i = e(0, this.currentTime / this.duration, 1);\n      s = i >= 1;\n      const o = s ? 1 : this.easing(i);\n      this.value = this.from + (this.to - this.from) * o;\n    }\n    var o, n, l;\n    null == (i = this.onUpdate) || i.call(this, this.value, s), s && this.stop();\n  }\n  stop() {\n    this.isRunning = !1;\n  }\n  fromTo(t, e, _ref) {\n    let {\n      lerp: i = .1,\n      duration: s = 1,\n      easing: o = t => t,\n      onStart: n,\n      onUpdate: l\n    } = _ref;\n    this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, null == n || n(), this.onUpdate = l;\n  }\n}\nclass s {\n  constructor() {\n    let {\n      wrapper: t,\n      content: e,\n      autoResize: i = !0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.resize = () => {\n      this.onWrapperResize(), this.onContentResize();\n    }, this.onWrapperResize = () => {\n      this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight);\n    }, this.onContentResize = () => {\n      this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth;\n    }, this.wrapper = t, this.content = e, i) {\n      const t = function (t, e) {\n        let i;\n        return function () {\n          let e = arguments,\n            s = this;\n          clearTimeout(i), i = setTimeout(function () {\n            t.apply(s, e);\n          }, 250);\n        };\n      }(this.resize);\n      this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(t), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(t), this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  destroy() {\n    var t, e;\n    null == (t = this.wrapperResizeObserver) || t.disconnect(), null == (e = this.contentResizeObserver) || e.disconnect();\n  }\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n}\nclass o {\n  constructor() {\n    this.events = {};\n  }\n  emit(t) {\n    let i = this.events[t] || [];\n    for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      e[_key - 1] = arguments[_key];\n    }\n    for (let t = 0, s = i.length; t < s; t++) i[t](...e);\n  }\n  on(t, e) {\n    var i;\n    return (null == (i = this.events[t]) ? void 0 : i.push(e)) || (this.events[t] = [e]), () => {\n      var i;\n      this.events[t] = null == (i = this.events[t]) ? void 0 : i.filter(t => e !== t);\n    };\n  }\n  off(t, e) {\n    var i;\n    this.events[t] = null == (i = this.events[t]) ? void 0 : i.filter(t => e !== t);\n  }\n  destroy() {\n    this.events = {};\n  }\n}\nclass n {\n  constructor(t, _ref2) {\n    let {\n      wheelMultiplier: i = 1,\n      touchMultiplier: s = 2,\n      normalizeWheel: n = !1\n    } = _ref2;\n    this.onTouchStart = t => {\n      const {\n        clientX: e,\n        clientY: i\n      } = t.targetTouches ? t.targetTouches[0] : t;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: 0,\n        y: 0\n      };\n    }, this.onTouchMove = t => {\n      const {\n          clientX: e,\n          clientY: i\n        } = t.targetTouches ? t.targetTouches[0] : t,\n        s = -(e - this.touchStart.x) * this.touchMultiplier,\n        o = -(i - this.touchStart.y) * this.touchMultiplier;\n      this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {\n        x: s,\n        y: o\n      }, this.emitter.emit(\"scroll\", {\n        deltaX: s,\n        deltaY: o,\n        event: t\n      });\n    }, this.onTouchEnd = t => {\n      this.emitter.emit(\"scroll\", {\n        deltaX: this.lastDelta.x,\n        deltaY: this.lastDelta.y,\n        event: t\n      });\n    }, this.onWheel = t => {\n      let {\n        deltaX: i,\n        deltaY: s\n      } = t;\n      this.normalizeWheel && (i = e(-100, i, 100), s = e(-100, s, 100)), i *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit(\"scroll\", {\n        deltaX: i,\n        deltaY: s,\n        event: t\n      });\n    }, this.element = t, this.wheelMultiplier = i, this.touchMultiplier = s, this.normalizeWheel = n, this.touchStart = {\n      x: null,\n      y: null\n    }, this.emitter = new o(), this.element.addEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.addEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.addEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.addEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  destroy() {\n    this.emitter.destroy(), this.element.removeEventListener(\"wheel\", this.onWheel, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchstart\", this.onTouchStart, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchmove\", this.onTouchMove, {\n      passive: !1\n    }), this.element.removeEventListener(\"touchend\", this.onTouchEnd, {\n      passive: !1\n    });\n  }\n}\nclass l {\n  constructor() {\n    let {\n      wrapper: e = window,\n      content: l = document.documentElement,\n      wheelEventsTarget: r = e,\n      eventsTarget: h = r,\n      smoothWheel: a = !0,\n      smoothTouch: c = !1,\n      syncTouch: u = !1,\n      syncTouchLerp: p = .1,\n      __iosNoInertiaSyncTouchLerp: d = .4,\n      touchInertiaMultiplier: m = 35,\n      duration: v,\n      easing: g = t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n      lerp: S = !v && .1,\n      infinite: w = !1,\n      orientation: f = \"vertical\",\n      gestureOrientation: y = \"vertical\",\n      touchMultiplier: T = 1,\n      wheelMultiplier: z = 1,\n      normalizeWheel: _ = !1,\n      autoResize: M = !0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.onVirtualScroll = _ref3 => {\n      let {\n        deltaX: e,\n        deltaY: i,\n        event: s\n      } = _ref3;\n      if (s.ctrlKey) return;\n      const o = s.type.includes(\"touch\"),\n        n = s.type.includes(\"wheel\");\n      if (\"both\" === this.options.gestureOrientation && 0 === e && 0 === i || \"vertical\" === this.options.gestureOrientation && 0 === i || \"horizontal\" === this.options.gestureOrientation && 0 === e || o && \"vertical\" === this.options.gestureOrientation && 0 === this.scroll && !this.options.infinite && i <= 0) return;\n      let l = s.composedPath();\n      if (l = l.slice(0, l.indexOf(this.rootElement)), l.find(t => {\n        var e;\n        return (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent\")) || o && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-touch\")) || n && (null == t.hasAttribute ? void 0 : t.hasAttribute(\"data-lenis-prevent-wheel\")) || (null == (e = t.classList) ? void 0 : e.contains(\"lenis\"));\n      })) return;\n      if (this.isStopped || this.isLocked) return void s.preventDefault();\n      if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && o || this.options.smoothWheel && n, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();\n      s.preventDefault();\n      let r = i;\n      \"both\" === this.options.gestureOrientation ? r = Math.abs(i) > Math.abs(e) ? i : e : \"horizontal\" === this.options.gestureOrientation && (r = e);\n      const h = o && this.options.syncTouch,\n        a = o && \"touchend\" === s.type && Math.abs(r) > 1;\n      a && (r = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + r, t({\n        programmatic: !1\n      }, h && {\n        lerp: a ? this.syncTouchLerp : this.options.__iosNoInertiaSyncTouchLerp\n      }));\n    }, this.onNativeScroll = () => {\n      if (!this.__preventNextScrollEvent && !this.isScrolling) {\n        const t = this.animatedScroll;\n        this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit();\n      }\n    }, window.lenisVersion = \"1.0.29\", e !== document.documentElement && e !== document.body || (e = window), this.options = {\n      wrapper: e,\n      content: l,\n      wheelEventsTarget: r,\n      eventsTarget: h,\n      smoothWheel: a,\n      smoothTouch: c,\n      syncTouch: u,\n      syncTouchLerp: p,\n      __iosNoInertiaSyncTouchLerp: d,\n      touchInertiaMultiplier: m,\n      duration: v,\n      easing: g,\n      lerp: S,\n      infinite: w,\n      gestureOrientation: y,\n      orientation: f,\n      touchMultiplier: T,\n      wheelMultiplier: z,\n      normalizeWheel: _,\n      autoResize: M\n    }, this.animate = new i(), this.emitter = new o(), this.dimensions = new s({\n      wrapper: e,\n      content: l,\n      autoResize: M\n    }), this.toggleClass(\"lenis\", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = u || a || c, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll = new n(h, {\n      touchMultiplier: T,\n      wheelMultiplier: z,\n      normalizeWheel: _\n    }), this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n  }\n  destroy() {\n    this.emitter.destroy(), this.options.wrapper.removeEventListener(\"scroll\", this.onNativeScroll, {\n      passive: !1\n    }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass(\"lenis\", !1), this.toggleClass(\"lenis-smooth\", !1), this.toggleClass(\"lenis-scrolling\", !1), this.toggleClass(\"lenis-stopped\", !1), this.toggleClass(\"lenis-locked\", !1);\n  }\n  on(t, e) {\n    return this.emitter.on(t, e);\n  }\n  off(t, e) {\n    return this.emitter.off(t, e);\n  }\n  setScroll(t) {\n    this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t;\n  }\n  resize() {\n    this.dimensions.resize();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  reset() {\n    this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop();\n  }\n  start() {\n    this.isStopped = !1, this.reset();\n  }\n  stop() {\n    this.isStopped = !0, this.animate.stop(), this.reset();\n  }\n  raf(t) {\n    const e = t - (this.time || t);\n    this.time = t, this.animate.advance(.001 * e);\n  }\n  scrollTo(t) {\n    let {\n      offset: i = 0,\n      immediate: s = !1,\n      lock: o = !1,\n      duration: n = this.options.duration,\n      easing: l = this.options.easing,\n      lerp: r = !n && this.options.lerp,\n      onComplete: h = null,\n      force: a = !1,\n      programmatic: c = !0\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.isStopped && !this.isLocked || a) {\n      if ([\"top\", \"left\", \"start\"].includes(t)) t = 0;else if ([\"bottom\", \"right\", \"end\"].includes(t)) t = this.limit;else {\n        var u;\n        let e;\n        if (\"string\" == typeof t ? e = document.querySelector(t) : null != (u = t) && u.nodeType && (e = t), e) {\n          if (this.options.wrapper !== window) {\n            const t = this.options.wrapper.getBoundingClientRect();\n            i -= this.isHorizontal ? t.left : t.top;\n          }\n          const s = e.getBoundingClientRect();\n          t = (this.isHorizontal ? s.left : s.top) + this.animatedScroll;\n        }\n      }\n      if (\"number\" == typeof t) {\n        if (t += i, t = Math.round(t), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : t = e(0, t, this.limit), s) return this.animatedScroll = this.targetScroll = t, this.setScroll(this.scroll), this.reset(), void (null == h || h(this));\n        if (!c) {\n          if (t === this.targetScroll) return;\n          this.targetScroll = t;\n        }\n        this.animate.fromTo(this.animatedScroll, t, {\n          duration: n,\n          easing: l,\n          lerp: r,\n          onStart: () => {\n            o && (this.isLocked = !0), this.isScrolling = !0;\n          },\n          onUpdate: (t, e) => {\n            this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), null == h || h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {\n              delete this.__preventNextScrollEvent;\n            }));\n          }\n        });\n      }\n    }\n  }\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  get limit() {\n    return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n  }\n  get isHorizontal() {\n    return \"horizontal\" === this.options.orientation;\n  }\n  get actualScroll() {\n    return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop;\n  }\n  get scroll() {\n    return this.options.infinite ? (this.animatedScroll % (t = this.limit) + t) % t : this.animatedScroll;\n    var t;\n  }\n  get progress() {\n    return 0 === this.limit ? 1 : this.scroll / this.limit;\n  }\n  get isSmooth() {\n    return this.__isSmooth;\n  }\n  set isSmooth(t) {\n    this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClass(\"lenis-smooth\", t));\n  }\n  get isScrolling() {\n    return this.__isScrolling;\n  }\n  set isScrolling(t) {\n    this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClass(\"lenis-scrolling\", t));\n  }\n  get isStopped() {\n    return this.__isStopped;\n  }\n  set isStopped(t) {\n    this.__isStopped !== t && (this.__isStopped = t, this.toggleClass(\"lenis-stopped\", t));\n  }\n  get isLocked() {\n    return this.__isLocked;\n  }\n  set isLocked(t) {\n    this.__isLocked !== t && (this.__isLocked = t, this.toggleClass(\"lenis-locked\", t));\n  }\n  get className() {\n    let t = \"lenis\";\n    return this.isStopped && (t += \" lenis-stopped\"), this.isLocked && (t += \" lenis-locked\"), this.isScrolling && (t += \" lenis-scrolling\"), this.isSmooth && (t += \" lenis-smooth\"), t;\n  }\n  toggleClass(t, e) {\n    this.rootElement.classList.toggle(t, e), this.emitter.emit(\"className change\", this);\n  }\n}\nexport { l as default };","map":{"version":3,"names":["e","t","i","Math","max","min","advance","isRunning","s","lerp","value","o","n","to","l","exp","round","currentTime","duration","easing","from","onUpdate","call","stop","fromTo","_ref","onStart","constructor","wrapper","content","autoResize","arguments","length","undefined","resize","onWrapperResize","onContentResize","window","width","innerWidth","height","innerHeight","clientWidth","clientHeight","scrollHeight","scrollWidth","clearTimeout","setTimeout","apply","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","limit","x","y","events","emit","_len","Array","_key","on","push","filter","off","_ref2","wheelMultiplier","touchMultiplier","normalizeWheel","onTouchStart","clientX","clientY","targetTouches","touchStart","lastDelta","onTouchMove","emitter","deltaX","deltaY","event","onTouchEnd","onWheel","element","addEventListener","passive","removeEventListener","document","documentElement","wheelEventsTarget","r","eventsTarget","h","smoothWheel","a","smoothTouch","c","syncTouch","u","syncTouchLerp","p","__iosNoInertiaSyncTouchLerp","d","touchInertiaMultiplier","m","v","g","pow","S","infinite","w","orientation","f","gestureOrientation","T","z","_","M","onVirtualScroll","_ref3","ctrlKey","type","includes","options","scroll","composedPath","slice","indexOf","rootElement","find","hasAttribute","classList","contains","isStopped","isLocked","preventDefault","isSmooth","isScrolling","animate","abs","velocity","scrollTo","targetScroll","programmatic","onNativeScroll","__preventNextScrollEvent","animatedScroll","actualScroll","direction","sign","lenisVersion","body","dimensions","toggleClass","virtualScroll","setScroll","isHorizontal","scrollLeft","scrollTop","reset","start","raf","time","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","requestAnimationFrame","progress","__isSmooth","__isScrolling","__isStopped","__isLocked","className","toggle","default"],"sources":["C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\maths.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\animate.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\dimensions.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\debounce.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\emitter.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\virtual-scroll.js","C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\@studio-freight\\lenis\\src\\index.js"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(\r\n    from,\r\n    to,\r\n    { lerp = 0.1, duration = 1, easing = (t) => t, onStart, onUpdate }\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\nexport class Dimensions {\r\n  constructor({ wrapper, content, autoResize = true } = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      const resize = debounce(this.resize, 250)\r\n\r\n      if (this.wrapper !== window) {\r\n        this.wrapperResizeObserver = new ResizeObserver(resize)\r\n        this.wrapperResizeObserver.observe(this.wrapper)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(resize)\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    this.scrollHeight = this.content.scrollHeight\r\n    this.scrollWidth = this.content.scrollWidth\r\n  }\r\n\r\n  get limit() {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event, ...args) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event, cb) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\r\n    }\r\n  }\r\n\r\n  off(event, callback) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\nimport { clamp } from './maths'\r\n\r\nexport class VirtualScroll {\r\n  constructor(\r\n    element,\r\n    { wheelMultiplier = 1, touchMultiplier = 2, normalizeWheel = false }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n    this.normalizeWheel = normalizeWheel\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, { passive: false })\r\n    this.element.addEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchstart', this.onTouchStart, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchmove', this.onTouchMove, {\r\n      passive: false,\r\n    })\r\n    this.element.removeEventListener('touchend', this.onTouchEnd, {\r\n      passive: false,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event) => {\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event) => {\r\n    let { deltaX, deltaY } = event\r\n\r\n    if (this.normalizeWheel) {\r\n      deltaX = clamp(-100, deltaX, 100)\r\n      deltaY = clamp(-100, deltaY, 100)\r\n    }\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n}\r\n","import { version } from '../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\nexport default class Lenis {\r\n  // isScrolling = true when scroll is animating\r\n  // isStopped = true if user should not be able to scroll - enable/disable programmatically\r\n  // isSmooth = true if scroll should be animated\r\n  // isLocked = same as isStopped but enabled/disabled when scroll reaches target\r\n\r\n  /**\r\n   * @typedef {(t: number) => number} EasingFunction\r\n   * @typedef {'vertical' | 'horizontal'} Orientation\r\n   * @typedef {'vertical' | 'horizontal' | 'both'} GestureOrientation\r\n   *\r\n   * @typedef LenisOptions\r\n   * @property {Window | HTMLElement} [wrapper]\r\n   * @property {HTMLElement} [content]\r\n   * @property {Window | HTMLElement} [wheelEventsTarget] // deprecated\r\n   * @property {Window | HTMLElement} [eventsTarget]\r\n   * @property {boolean} [smoothWheel]\r\n   * @property {boolean} [smoothTouch]\r\n   * @property {boolean} [syncTouch]\r\n   * @property {number} [syncTouchLerp]\r\n   * @property {number} [__iosNoInertiaSyncTouchLerp]\r\n   * @property {number} [touchInertiaMultiplier]\r\n   * @property {number} [duration]\r\n   * @property {EasingFunction} [easing]\r\n   * @property {number} [lerp]\r\n   * @property {boolean} [infinite]\r\n   * @property {Orientation} [orientation]\r\n   * @property {GestureOrientation} [gestureOrientation]\r\n   * @property {number} [touchMultiplier]\r\n   * @property {number} [wheelMultiplier]\r\n   * @property {boolean} [normalizeWheel]\r\n   * @property {boolean} [autoResize]\r\n   *\r\n   * @param {LenisOptions}\r\n   */\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper, // deprecated\r\n    eventsTarget = wheelEventsTarget,\r\n    smoothWheel = true,\r\n    smoothTouch = false,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.1,\r\n    __iosNoInertiaSyncTouchLerp = 0.4, // should be 1 but had to leave 0.4 for iOS (testing purpose)\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = !duration && 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    normalizeWheel = false,\r\n    autoResize = true,\r\n  } = {}) {\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (wrapper === document.documentElement || wrapper === document.body) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      eventsTarget,\r\n      smoothWheel,\r\n      smoothTouch,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      __iosNoInertiaSyncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n      autoResize,\r\n    }\r\n\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    this.toggleClass('lenis', true)\r\n\r\n    this.velocity = 0\r\n    this.isLocked = false\r\n    this.isStopped = false\r\n    this.isSmooth = syncTouch || smoothWheel || smoothTouch\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      normalizeWheel,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener('scroll', this.onNativeScroll, {\r\n      passive: false,\r\n    })\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.toggleClass('lenis', false)\r\n    this.toggleClass('lenis-smooth', false)\r\n    this.toggleClass('lenis-scrolling', false)\r\n    this.toggleClass('lenis-stopped', false)\r\n    this.toggleClass('lenis-locked', false)\r\n  }\r\n\r\n  on(event, callback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event, callback) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  setScroll(scroll) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  onVirtualScroll = ({ deltaX, deltaY, event }) => {\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    if (\r\n      (this.options.gestureOrientation === 'both' &&\r\n        deltaX === 0 &&\r\n        deltaY === 0) || // \"touchend\" events prevents \"click\"\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) || // trackpad previous/next page gesture\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0) ||\r\n      (isTouch &&\r\n        this.options.gestureOrientation === 'vertical' &&\r\n        this.scroll === 0 &&\r\n        !this.options.infinite &&\r\n        deltaY <= 0) // touch pull to refresh\r\n    )\r\n      return\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node.hasAttribute?.('data-lenis-prevent') ||\r\n          (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n          (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n          node.classList?.contains('lenis') // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault()\r\n      return\r\n    }\r\n\r\n    this.isSmooth =\r\n      ((this.options.smoothTouch || this.options.syncTouch) && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!this.isSmooth) {\r\n      this.isScrolling = false\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 1\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch && {\r\n        lerp: hasTouchInertia\r\n          ? this.syncTouchLerp\r\n          : this.options.__iosNoInertiaSyncTouchLerp,\r\n      }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  onNativeScroll = () => {\r\n    if (this.__preventNextScrollEvent) return\r\n\r\n    if (!this.isScrolling) {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.velocity = 0\r\n      this.direction = Math.sign(this.animatedScroll - lastScroll)\r\n      this.emit()\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.animatedScroll = this.targetScroll = this.actualScroll\r\n    this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = !duration && this.options.lerp,\r\n      onComplete = null,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n    } = {}\r\n  ) {\r\n    if ((this.isStopped || this.isLocked) && !force) return\r\n\r\n    // keywords\r\n    if (['top', 'left', 'start'].includes(target)) {\r\n      target = 0\r\n    } else if (['bottom', 'right', 'end'].includes(target)) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.options.wrapper.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      onComplete?.(this)\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      if (target === this.targetScroll) return\r\n\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onStart: () => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = true\r\n      },\r\n      onUpdate: (value, completed) => {\r\n        this.isScrolling = true\r\n\r\n        // updated\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity)\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        if (!completed) this.emit()\r\n\r\n        if (completed) {\r\n          this.reset()\r\n          this.emit()\r\n          onComplete?.(this)\r\n\r\n          // avoid emitting event twice\r\n          this.__preventNextScrollEvent = true\r\n          requestAnimationFrame(() => {\r\n            delete this.__preventNextScrollEvent\r\n          })\r\n        }\r\n      },\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return this.options.wrapper === window\r\n      ? document.documentElement\r\n      : this.options.wrapper\r\n  }\r\n\r\n  get limit() {\r\n    return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll() {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll() {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress() {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.__isSmooth\r\n  }\r\n\r\n  set isSmooth(value) {\r\n    if (this.__isSmooth !== value) {\r\n      this.__isSmooth = value\r\n      this.toggleClass('lenis-smooth', value)\r\n    }\r\n  }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  set isScrolling(value) {\r\n    if (this.__isScrolling !== value) {\r\n      this.__isScrolling = value\r\n      this.toggleClass('lenis-scrolling', value)\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  set isStopped(value) {\r\n    if (this.__isStopped !== value) {\r\n      this.__isStopped = value\r\n      this.toggleClass('lenis-stopped', value)\r\n    }\r\n  }\r\n\r\n  get isLocked() {\r\n    return this.__isLocked\r\n  }\r\n\r\n  set isLocked(value) {\r\n    if (this.__isLocked !== value) {\r\n      this.__isLocked = value\r\n      this.toggleClass('lenis-locked', value)\r\n    }\r\n  }\r\n\r\n  get className() {\r\n    let className = 'lenis'\r\n    if (this.isStopped) className += ' lenis-stopped'\r\n    if (this.isLocked) className += ' lenis-locked'\r\n    if (this.isScrolling) className += ' lenis-scrolling'\r\n    if (this.isSmooth) className += ' lenis-smooth'\r\n    return className\r\n  }\r\n\r\n  toggleClass(name, value) {\r\n    this.rootElement.classList.toggle(name, value)\r\n    this.emitter.emit('className change', this)\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { clamp } from './utils';\nimport { Options } from './options';\nimport { setStyle, clearEventsOn } from './utils/';\nimport { debounce } from './decorators/';\nimport { TrackController } from './track/';\nimport { getSize, update, isVisible } from './geometry/';\nimport { scrollTo, setPosition, scrollIntoView } from './scrolling/';\nimport { initPlugins } from './plugin';\nimport * as eventHandlers from './events/';\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nexport var scrollbarMap = new Map();\nvar Scrollbar = /** @class */function () {\n  function Scrollbar(containerEl, options) {\n    var _this = this;\n    /**\n     * Current scrolling offsets\n     */\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Max-allowed scrolling offsets\n     */\n    this.limit = {\n      x: Infinity,\n      y: Infinity\n    };\n    /**\n     * Container bounding rect\n     */\n    this.bounding = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    // private _observer: ResizeObserver;\n    this._plugins = [];\n    this._momentum = {\n      x: 0,\n      y: 0\n    };\n    this._listeners = new Set();\n    this.containerEl = containerEl;\n    var contentEl = this.contentEl = document.createElement('div');\n    this.options = new Options(options);\n    // mark as a scroll element\n    containerEl.setAttribute('data-scrollbar', 'true');\n    // make container focusable\n    containerEl.setAttribute('tabindex', '-1');\n    setStyle(containerEl, {\n      overflow: 'hidden',\n      outline: 'none'\n    });\n    // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    }\n    // mount content\n    contentEl.className = 'scroll-content';\n    Array.from(containerEl.childNodes).forEach(function (node) {\n      contentEl.appendChild(node);\n    });\n    containerEl.appendChild(contentEl);\n    // attach track\n    this.track = new TrackController(this);\n    // initial measuring\n    this.size = this.getSize();\n    // init plugins\n    this._plugins = initPlugins(this, this.options.plugins);\n    // preserve scroll offset\n    var scrollLeft = containerEl.scrollLeft,\n      scrollTop = containerEl.scrollTop;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true\n    });\n    // FIXME: update typescript\n    var ResizeObserver = window.ResizeObserver;\n    // observe\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(function () {\n        _this.update();\n      });\n      this._observer.observe(contentEl);\n    }\n    scrollbarMap.set(containerEl, this);\n    // wait for DOM ready\n    requestAnimationFrame(function () {\n      _this._init();\n    });\n  }\n  Object.defineProperty(Scrollbar.prototype, \"parent\", {\n    /**\n     * Parent scrollbar\n     */\n    get: function () {\n      var elem = this.containerEl.parentElement;\n      while (elem) {\n        var parentScrollbar = scrollbarMap.get(elem);\n        if (parentScrollbar) {\n          return parentScrollbar;\n        }\n        elem = elem.parentElement;\n      }\n      return null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollTop\", {\n    /**\n     * Gets or sets `scrollbar.offset.y`\n     */\n    get: function () {\n      return this.offset.y;\n    },\n    set: function (y) {\n      this.setPosition(this.scrollLeft, y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollLeft\", {\n    /**\n     * Gets or sets `scrollbar.offset.x`\n     */\n    get: function () {\n      return this.offset.x;\n    },\n    set: function (x) {\n      this.setPosition(x, this.scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n  Scrollbar.prototype.getSize = function () {\n    return getSize(this);\n  };\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n  Scrollbar.prototype.update = function () {\n    update(this);\n    this._plugins.forEach(function (plugin) {\n      plugin.onUpdate();\n    });\n  };\n  /**\n   * Checks if an element is visible in the current view area\n   */\n  Scrollbar.prototype.isVisible = function (elem) {\n    return isVisible(this, elem);\n  };\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n  Scrollbar.prototype.setPosition = function (x, y, options) {\n    var _this = this;\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    var status = setPosition(this, x, y);\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n    this._listeners.forEach(function (fn) {\n      fn.call(_this, status);\n    });\n  };\n  /**\n   * Scrolls to given position with easing function\n   */\n  Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n    if (duration === void 0) {\n      duration = 0;\n    }\n    if (options === void 0) {\n      options = {};\n    }\n    scrollTo(this, x, y, duration, options);\n  };\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n  Scrollbar.prototype.scrollIntoView = function (elem, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    scrollIntoView(this, elem, options);\n  };\n  /**\n   * Adds scrolling listener\n   */\n  Scrollbar.prototype.addListener = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n    this._listeners.add(fn);\n  };\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n  Scrollbar.prototype.removeListener = function (fn) {\n    this._listeners.delete(fn);\n  };\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n  Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n    this._updateDebounced();\n    var finalDelta = this._plugins.reduce(function (delta, plugin) {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, {\n      x: x,\n      y: y\n    });\n    var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  };\n  /**\n   * Increases scrollbar's momentum\n   */\n  Scrollbar.prototype.addMomentum = function (x, y) {\n    this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n  };\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n  Scrollbar.prototype.setMomentum = function (x, y) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    this._momentum.x = x;\n    this._momentum.y = y;\n  };\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n  Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n    this._plugins.forEach(function (plugin) {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  };\n  Scrollbar.prototype.destroy = function () {\n    var _a = this,\n      containerEl = _a.containerEl,\n      contentEl = _a.contentEl;\n    clearEventsOn(this);\n    this._listeners.clear();\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    scrollbarMap.delete(this.containerEl);\n    // restore contents\n    var childNodes = Array.from(contentEl.childNodes);\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n    childNodes.forEach(function (el) {\n      containerEl.appendChild(el);\n    });\n    // reset scroll position\n    setStyle(containerEl, {\n      overflow: ''\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft;\n    // invoke plugin.onDestroy\n    this._plugins.forEach(function (plugin) {\n      plugin.onDestroy();\n    });\n    this._plugins.length = 0;\n  };\n  Scrollbar.prototype._init = function () {\n    var _this = this;\n    this.update();\n    // init evet handlers\n    Object.keys(eventHandlers).forEach(function (prop) {\n      eventHandlers[prop](_this);\n    });\n    // invoke `plugin.onInit`\n    this._plugins.forEach(function (plugin) {\n      plugin.onInit();\n    });\n    this._render();\n  };\n  Scrollbar.prototype._updateDebounced = function () {\n    this.update();\n  };\n  // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n  Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n    if (deltaX === void 0) {\n      deltaX = 0;\n    }\n    if (deltaY === void 0) {\n      deltaY = 0;\n    }\n    var _a = this,\n      options = _a.options,\n      offset = _a.offset,\n      limit = _a.limit;\n    if (!options.continuousScrolling) return false;\n    // force an update when scrollbar is \"unscrollable\", see #106\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n    var destX = clamp(deltaX + offset.x, 0, limit.x);\n    var destY = clamp(deltaY + offset.y, 0, limit.y);\n    var res = true;\n    // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n    res = res && destX === offset.x;\n    res = res && destY === offset.y;\n    // current offsets are on the edge\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n    return res;\n  };\n  Scrollbar.prototype._render = function () {\n    var _momentum = this._momentum;\n    if (_momentum.x || _momentum.y) {\n      var nextX = this._nextTick('x');\n      var nextY = this._nextTick('y');\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n      this.setPosition(nextX.position, nextY.position);\n    }\n    var remain = __assign({}, this._momentum);\n    this._plugins.forEach(function (plugin) {\n      plugin.onRender(remain);\n    });\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  };\n  Scrollbar.prototype._nextTick = function (direction) {\n    var _a = this,\n      options = _a.options,\n      offset = _a.offset,\n      _momentum = _a._momentum;\n    var current = offset[direction];\n    var remain = _momentum[direction];\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain\n      };\n    }\n    var nextMomentum = remain * (1 - options.damping);\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum\n    };\n  };\n  __decorate([debounce(100, true)], Scrollbar.prototype, \"_updateDebounced\", null);\n  return Scrollbar;\n}();\nexport { Scrollbar };","map":{"version":3,"names":["clamp","Options","setStyle","clearEventsOn","debounce","TrackController","getSize","update","isVisible","scrollTo","setPosition","scrollIntoView","initPlugins","eventHandlers","scrollbarMap","Map","Scrollbar","containerEl","options","_this","offset","x","y","limit","Infinity","bounding","top","right","bottom","left","_plugins","_momentum","_listeners","Set","contentEl","document","createElement","setAttribute","overflow","outline","window","navigator","msPointerEnabled","style","msTouchAction","className","Array","from","childNodes","forEach","node","appendChild","track","size","plugins","scrollLeft","scrollTop","withoutCallbacks","ResizeObserver","_observer","observe","set","requestAnimationFrame","_init","Object","defineProperty","prototype","get","elem","parentElement","parentScrollbar","plugin","onUpdate","status","fn","call","duration","addListener","TypeError","add","removeListener","delete","addTransformableMomentum","fromEvent","callback","_updateDebounced","finalDelta","reduce","delta","transformDelta","willScroll","_shouldPropagateMomentum","addMomentum","setMomentum","renderByPixels","Math","round","updatePluginOptions","pluginName","name","assign","destroy","_a","clear","cancelAnimationFrame","_renderID","disconnect","firstChild","removeChild","el","onDestroy","length","keys","prop","onInit","_render","deltaX","deltaY","continuousScrolling","destX","destY","res","nextX","_nextTick","nextY","momentum","position","remain","__assign","onRender","bind","direction","current","abs","nextMomentum","damping","__decorate"],"sources":["C:\\Users\\aashn\\OneDrive\\Documents\\Aashna\\3_PROJECTS\\programming\\personal-website\\node_modules\\smooth-scrollbar\\src\\scrollbar.ts"],"sourcesContent":["import { clamp } from './utils';\n\nimport { Options } from './options';\n\nimport {\n  setStyle,\n  clearEventsOn,\n} from './utils/';\n\nimport {\n  debounce,\n} from './decorators/';\n\nimport {\n  TrackController,\n} from './track/';\n\nimport {\n  getSize,\n  update,\n  isVisible,\n} from './geometry/';\n\nimport {\n  scrollTo,\n  setPosition,\n  scrollIntoView,\n} from './scrolling/';\n\nimport {\n  initPlugins,\n} from './plugin';\n\nimport * as eventHandlers from './events/';\n\nimport * as I from './interfaces/';\n\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nexport const scrollbarMap = new Map<HTMLElement, Scrollbar>();\n\nexport class Scrollbar implements I.Scrollbar {\n  /**\n   * Options for current scrollbar instancs\n   */\n  readonly options: Options;\n\n  readonly track: TrackController;\n\n  /**\n   * The element that you initialized scrollbar to\n   */\n  readonly containerEl: HTMLElement;\n\n  /**\n   * The wrapper element that contains your contents\n   */\n  readonly contentEl: HTMLElement;\n\n  /**\n   * Geometry infomation for current scrollbar instance\n   */\n  size: I.ScrollbarSize;\n\n  /**\n   * Current scrolling offsets\n   */\n  offset = {\n    x: 0,\n    y: 0,\n  };\n\n  /**\n   * Max-allowed scrolling offsets\n   */\n  limit = {\n    x: Infinity,\n    y: Infinity,\n  };\n\n  /**\n   * Container bounding rect\n   */\n  bounding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  };\n\n  /**\n   * Parent scrollbar\n   */\n  get parent() {\n    let elem = this.containerEl.parentElement;\n\n    while (elem) {\n      const parentScrollbar = scrollbarMap.get(elem);\n\n      if (parentScrollbar) {\n        return parentScrollbar;\n      }\n\n      elem = elem.parentElement;\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets or sets `scrollbar.offset.y`\n   */\n  get scrollTop() {\n    return this.offset.y;\n  }\n  set scrollTop(y: number) {\n    this.setPosition(this.scrollLeft, y);\n  }\n\n  /**\n   * Gets or sets `scrollbar.offset.x`\n   */\n  get scrollLeft() {\n    return this.offset.x;\n  }\n  set scrollLeft(x: number) {\n    this.setPosition(x, this.scrollTop);\n  }\n\n  private _renderID: number;\n  private _observer: any; // FIXME: we need to update typescript version to support `ResizeObserver`\n  // private _observer: ResizeObserver;\n  private _plugins: I.ScrollbarPlugin[] = [];\n\n  private _momentum = { x: 0, y: 0 };\n  private _listeners = new Set<I.ScrollListener>();\n\n  constructor(\n    containerEl: HTMLElement,\n    options?: Partial<I.ScrollbarOptions>,\n  ) {\n    this.containerEl = containerEl;\n    const contentEl = this.contentEl = document.createElement('div');\n\n    this.options = new Options(options);\n\n    // mark as a scroll element\n    containerEl.setAttribute('data-scrollbar', 'true');\n\n    // make container focusable\n    containerEl.setAttribute('tabindex', '-1');\n    setStyle(containerEl, {\n      overflow: 'hidden',\n      outline: 'none',\n    });\n\n    // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    }\n\n    // mount content\n    contentEl.className = 'scroll-content';\n\n    Array.from(containerEl.childNodes).forEach((node) => {\n      contentEl.appendChild(node);\n    });\n\n    containerEl.appendChild(contentEl);\n\n    // attach track\n    this.track = new TrackController(this);\n\n    // initial measuring\n    this.size = this.getSize();\n\n    // init plugins\n    this._plugins = initPlugins(this, this.options.plugins);\n\n    // preserve scroll offset\n    const { scrollLeft, scrollTop } = containerEl;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true,\n    });\n\n    // FIXME: update typescript\n    const ResizeObserver = (window as any).ResizeObserver;\n\n    // observe\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(() => {\n        this.update();\n      });\n\n      this._observer.observe(contentEl);\n    }\n\n    scrollbarMap.set(containerEl, this);\n\n    // wait for DOM ready\n    requestAnimationFrame(() => {\n      this._init();\n    });\n  }\n\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n  getSize(): I.ScrollbarSize {\n    return getSize(this);\n  }\n\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n  update() {\n    update(this);\n\n    this._plugins.forEach((plugin) => {\n      plugin.onUpdate();\n    });\n  }\n\n  /**\n   * Checks if an element is visible in the current view area\n   */\n  isVisible(elem: HTMLElement): boolean {\n    return isVisible(this, elem);\n  }\n\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n  setPosition(\n    x = this.offset.x,\n    y = this.offset.y,\n    options: Partial<I.SetPositionOptions> = {},\n  ) {\n    const status = setPosition(this, x, y);\n\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n\n    this._listeners.forEach((fn) => {\n      fn.call(this, status);\n    });\n  }\n\n  /**\n   * Scrolls to given position with easing function\n   */\n  scrollTo(\n    x = this.offset.x,\n    y = this.offset.y,\n    duration = 0,\n    options: Partial<I.ScrollToOptions> = {},\n  ) {\n    scrollTo(this, x, y, duration, options);\n  }\n\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n  scrollIntoView(\n    elem: HTMLElement,\n    options: Partial<I.ScrollIntoViewOptions> = {},\n  ) {\n    scrollIntoView(this, elem, options);\n  }\n\n  /**\n   * Adds scrolling listener\n   */\n  addListener(fn: I.ScrollListener) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n\n    this._listeners.add(fn);\n  }\n\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n  removeListener(fn: I.ScrollListener) {\n    this._listeners.delete(fn);\n  }\n\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n  addTransformableMomentum(\n    x: number,\n    y: number,\n    fromEvent: Event,\n    callback?: I.AddTransformableMomentumCallback,\n  ) {\n    this._updateDebounced();\n\n    const finalDelta = this._plugins.reduce((delta, plugin) => {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, { x, y });\n\n    const willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  }\n\n  /**\n   * Increases scrollbar's momentum\n   */\n  addMomentum(x: number, y: number) {\n    this.setMomentum(\n      this._momentum.x + x,\n      this._momentum.y + y,\n    );\n  }\n\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n  setMomentum(x: number, y: number) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    this._momentum.x = x;\n    this._momentum.y = y;\n  }\n\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n  updatePluginOptions(pluginName: string, options?: any) {\n    this._plugins.forEach((plugin) => {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  }\n\n  destroy() {\n    const {\n      containerEl,\n      contentEl,\n    } = this;\n\n    clearEventsOn(this);\n    this._listeners.clear();\n\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n\n    scrollbarMap.delete(this.containerEl);\n\n    // restore contents\n    const childNodes = Array.from(contentEl.childNodes);\n\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n\n    childNodes.forEach((el) => {\n      containerEl.appendChild(el);\n    });\n\n    // reset scroll position\n    setStyle(containerEl, {\n      overflow: '',\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft;\n\n    // invoke plugin.onDestroy\n    this._plugins.forEach((plugin) => {\n      plugin.onDestroy();\n    });\n    this._plugins.length = 0;\n  }\n\n  private _init() {\n    this.update();\n\n    // init evet handlers\n    Object.keys(eventHandlers).forEach((prop) => {\n      eventHandlers[prop](this);\n    });\n\n    // invoke `plugin.onInit`\n    this._plugins.forEach((plugin) => {\n      plugin.onInit();\n    });\n\n    this._render();\n  }\n\n  @debounce(100, true)\n  private _updateDebounced() {\n    this.update();\n  }\n\n  // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n  private _shouldPropagateMomentum(deltaX = 0, deltaY = 0): boolean {\n    const {\n      options,\n      offset,\n      limit,\n    } = this;\n\n    if (!options.continuousScrolling) return false;\n\n    // force an update when scrollbar is \"unscrollable\", see #106\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n\n    const destX = clamp(deltaX + offset.x, 0, limit.x);\n    const destY = clamp(deltaY + offset.y, 0, limit.y);\n    let res = true;\n\n    // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n    res = res && (destX === offset.x);\n    res = res && (destY === offset.y);\n\n    // current offsets are on the edge\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n\n    return res;\n  }\n\n  private _render() {\n    const {\n      _momentum,\n    } = this;\n\n    if (_momentum.x || _momentum.y) {\n      const nextX = this._nextTick('x');\n      const nextY = this._nextTick('y');\n\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n\n      this.setPosition(nextX.position, nextY.position);\n    }\n\n    const remain = { ...this._momentum };\n\n    this._plugins.forEach((plugin) => {\n      plugin.onRender(remain);\n    });\n\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  }\n\n  private _nextTick(direction: 'x' | 'y'): { momentum: number, position: number } {\n    const {\n      options,\n      offset,\n      _momentum,\n    } = this;\n\n    const current = offset[direction];\n    const remain = _momentum[direction];\n\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain,\n      };\n    }\n\n    let nextMomentum = remain * (1 - options.damping);\n\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum,\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
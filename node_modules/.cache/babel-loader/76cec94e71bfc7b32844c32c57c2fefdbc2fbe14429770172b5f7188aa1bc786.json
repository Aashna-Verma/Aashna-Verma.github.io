{"ast":null,"code":"/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.4\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(function () {\n  function append() {\n    var length = arguments.length;\n    for (var i = 0; i < length; i++) {\n      var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n  function replaceChildren() {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n    if (arguments.length) this.append.apply(this, arguments);\n  }\n  function replaceWith() {\n    var parent = this.parentNode;\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n    var i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n    while (i--) {\n      var node = nodes[i];\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce(function (extended, key) {\n    var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  var types;\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(function (type) {\n      return String(type).trim();\n    }).filter(function (type) {\n      return /((line)|(word)|(char))/i.test(type);\n    });\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  var types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  var elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n  return toArray(elements).reduce(function (result, element) {\n    return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\n  }, []);\n}\nvar entries = Object.entries;\nvar expando = \"_splittype\";\nvar cache = {};\nvar uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n  var id = owner[expando] || (owner[expando] = ++uid);\n  var data = cache[id] || (cache[id] = {});\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = _objectSpread2(_objectSpread2({}, data), key);\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n  return value;\n}\nfunction get(owner, key) {\n  var id = isObject(owner) ? owner[expando] : null;\n  var data = id && cache[id] || {};\n  if (key === undefined) {\n    return data;\n  }\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  var id = element && element[expando];\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Clear all cached data\n */\n\nfunction clear() {\n  Object.keys(cache).forEach(function (key) {\n    delete cache[key];\n  });\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      id = _ref2[0],\n      _ref2$ = _ref2[1],\n      isRoot = _ref2$.isRoot,\n      isSplit = _ref2$.isSplit;\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n  var string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */\n\nvar rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\";\nvar rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */\n\nvar reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\"\".concat(rsNonAstral).concat(rsCombo, \"?\"), rsCombo, rsRegional, rsSurrPair, rsAstral].join('|'), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nvar reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nvar unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(''), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */\n\nfunction toChars(string) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  string = toString(string);\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  var element = document.createElement(name);\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n  Object.keys(attributes).forEach(function (attribute) {\n    var rawValue = attributes[attribute];\n    var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append.apply(element, _toConsumableArray(toArray(value)));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  var types = parseTypes(settings.types); // the tag name for split text nodes\n\n  var TAG_NAME = settings.tagName; // value of the text node\n\n  var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  var words = [];\n  var chars = [];\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n  words = toWords(VALUE).reduce(function (result, WORD, idx, arr) {\n    // Let `wordElement` be the wrapped element for the current word\n    var wordElement;\n    var characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(function (CHAR) {\n        var characterElement = createElement(TAG_NAME, {\n          \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [].concat(_toConsumableArray(chars), [characterElement]);\n        return characterElement;\n      });\n    } // END IF;\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n        style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : ''),\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(function (characterElement) {\n        splitText.appendChild(characterElement);\n      });\n    }\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n  textNode.replaceWith(splitText);\n  return {\n    words: words,\n    chars: chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  var type = node.nodeType; // Arrays of split words and characters\n\n  var wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n  var childNodes = toArray(node.childNodes);\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      var nextSibling = node.nextSibling;\n      var prevSibling = node.previousSibling;\n      var text = node.textContent || '';\n      var textAfter = nextSibling ? nextSibling.textContent : ' ';\n      var textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n  return childNodes.reduce(function (result, child) {\n    var _split = split(child, settings),\n      words = _split.words,\n      chars = _split.chars;\n    return {\n      words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\n      chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n  var parent = node.offsetParent;\n  var _scrollPos = _slicedToArray(scrollPos, 2),\n    scrollX = _scrollPos[0],\n    scrollY = _scrollPos[1];\n  var parentX = 0;\n  var parentY = 0;\n  if (parent && parent !== document.body) {\n    var parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height,\n    x = _node$getBoundingClie.x,\n    y = _node$getBoundingClie.y;\n  var top = y + scrollY - parentY;\n  var left = x + scrollX - parentX;\n  return {\n    width: width,\n    height: height,\n    top: top,\n    left: left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(function (child) {\n      return unSplitWords(child);\n    });\n  } else {\n    remove(element);\n    element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\n  }\n}\nvar createFragment = function createFragment() {\n  return document.createDocumentFragment();\n};\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  var types = parseTypes(settings.types);\n  var TAG_NAME = settings.tagName;\n  var nodes = element.getElementsByTagName('*');\n  var wordsInEachLine = [];\n  var wordsInCurrentLine = [];\n  var lineOffsetY = null;\n  var elementHeight;\n  var elementWidth;\n  var contentBox;\n  var lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  var parent = element.parentElement;\n  var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  var splitText = createFragment(); // get the computed style object for the element\n\n  var cs = window.getComputedStyle(element);\n  var align = cs.textAlign;\n  var fontSize = parseFloat(cs.fontSize);\n  var lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n  toArray(nodes).forEach(function (node) {\n    // node is a word element or custom html element\n    var isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    var _getPosition = getPosition(node, isWordLike, settings, scrollPos),\n      width = _getPosition.width,\n      height = _getPosition.height,\n      top = _getPosition.top,\n      left = _getPosition.left; // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top: top,\n        left: left,\n        width: width,\n        height: height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(function (wordsInThisLine) {\n      // Create an element to wrap the current line.\n      var lineElement = createElement(TAG_NAME, {\n        \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n        style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n      });\n      set(lineElement, 'isLine', true);\n      var lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach(function (wordOrElement, idx, arr) {\n        var _data$get = get(wordOrElement),\n          isWordEnd = _data$get.isWordEnd,\n          top = _data$get.top,\n          height = _data$get.height;\n        var next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n    element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\n\n    toArray(nodes).forEach(function (node) {\n      var _data$get2 = get(node),\n        isLine = _data$get2.isLine,\n        top = _data$get2.top,\n        left = _data$get2.left,\n        width = _data$get2.width,\n        height = _data$get2.height;\n      var parentData = get(node.parentElement);\n      var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n\n      node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n  return lines;\n}\nvar _defaults = extend(defaults, {});\nvar SplitType = /*#__PURE__*/function () {\n  _createClass(SplitType, null, [{\n    key: \"clearData\",\n    /**\n     * CLears all data\n     */\n    value: function clearData() {\n      clear();\n    }\n    /**\n     * The default settings for all splitType instances\n     * @static\n     */\n  }, {\n    key: \"setDefaults\",\n    /**\n     * Sets the default settings for all SplitType instances.\n     * The provided object will be merged with the existing defaults objects.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @returns {Object} the new default settings\n     * @public\n     * @static\n     * @example\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\n     */\n    value: function setDefaults(options) {\n      _defaults = extend(_defaults, parseSettings(options));\n      return defaults;\n    }\n    /**\n     * Revert target elements to their original html content\n     * Has no effect on that\n     *\n     * @param {any} elements The target elements to revert. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @static\n     */\n  }, {\n    key: \"revert\",\n    value: function revert(elements) {\n      getTargetElements(elements).forEach(function (element) {\n        var _data$get = get(element),\n          isSplit = _data$get.isSplit,\n          html = _data$get.html,\n          cssWidth = _data$get.cssWidth,\n          cssHeight = _data$get.cssHeight;\n        if (isSplit) {\n          element.innerHTML = html;\n          element.style.width = cssWidth || '';\n          element.style.height = cssHeight || '';\n          remove(element);\n        }\n      });\n    }\n    /**\n     * Creates a new SplitType instance\n     * This static method provides a way to create a `SplitType` instance without\n     * using the `new` keyword.\n     *\n     * @param {any} target The target elements to split. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @param {Object} [options] Settings for the SplitType instance\n     * @return {SplitType} the SplitType instance\n     * @static\n     */\n  }, {\n    key: \"create\",\n    value: function create(target, options) {\n      return new SplitType(target, options);\n    }\n    /**\n     * Creates a new `SplitType` instance\n     *\n     * @param {any} elements The target elements to split. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @param {Object} [options] Settings for the SplitType instance\n     */\n  }, {\n    key: \"data\",\n    /**\n     * The internal data store\n     */\n    get: function get() {\n      return cache;\n    }\n  }, {\n    key: \"defaults\",\n    get: function get() {\n      return _defaults;\n    }\n    /**\n     * Sets the default settings for all SplitType instances.\n     *\n     * Setting `SplitType.defaults` to an object will merge that object with the\n     * existing defaults.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @deprecated\n     * @static\n     * @example\n     * SplitType.defaults = { \"position\": \"absolute\" }\n     */,\n\n    set: function set(options) {\n      _defaults = extend(_defaults, parseSettings(options));\n    }\n  }]);\n  function SplitType(elements, options) {\n    _classCallCheck(this, SplitType);\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n  _createClass(SplitType, [{\n    key: \"split\",\n    value: function split$1(options) {\n      var _this = this;\n\n      // Revert target elements (if they are already split)\n      // Note: revert was already called once in the constructor. However, we\n      // need to call it again here so text is reverted when the user manually\n      // calls the `split` method to re-split text.\n      this.revert(); // Store the original html content of each target element\n\n      this.elements.forEach(function (element) {\n        set(element, 'html', element.innerHTML);\n      }); // Create arrays to hold the split lines, words, and characters\n\n      this.lines = [];\n      this.words = [];\n      this.chars = []; // cache vertical scroll position before splitting\n\n      var scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n      if (options !== undefined) {\n        this.settings = extend(this.settings, parseSettings(options));\n      }\n      var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n      // @example new SplitType('#target', { types: [] })\n\n      if (types.none) {\n        return;\n      } // Split text in each target element\n\n      this.elements.forEach(function (element) {\n        // Add the split text nodes from this element to the arrays of all split\n        // text nodes for this instance.\n        set(element, 'isRoot', true);\n        var _split2 = split(element, _this.settings),\n          words = _split2.words,\n          chars = _split2.chars;\n        _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\n        _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\n      });\n      this.elements.forEach(function (element) {\n        if (types.lines || _this.settings.absolute) {\n          var lines = repositionAfterSplit(element, _this.settings, scrollPos);\n          _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\n        }\n      }); // Set isSplit to true for the SplitType instance\n\n      this.isSplit = true; // Set scroll position to cached value.\n\n      window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n      cleanup();\n    }\n    /**\n     * Reverts target element(s) back to their original html content\n     * Deletes all stored data associated with the target elements\n     * Resets the properties on the splitType instance\n     *\n     * @public\n     */\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      if (this.isSplit) {\n        // Reset instance properties if necessary\n        this.lines = null;\n        this.words = null;\n        this.chars = null;\n        this.isSplit = false;\n      }\n      SplitType.revert(this.elements);\n    }\n  }]);\n  return SplitType;\n}();\nexport { SplitType as default };","map":{"version":3,"names":["append","length","arguments","i","node","undefined","nodeType","appendChild","document","createTextNode","String","replaceChildren","lastChild","removeChild","apply","replaceWith","parent","parentNode","_len","nodes","Array","_key","ownerDocument","replaceChild","insertBefore","previousSibling","Element","prototype","DocumentFragment","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","obj","value","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","isArray","_arrayLikeToArray","iter","Symbol","iterator","from","_arr","_n","_d","_e","_i","_s","next","done","err","o","minLen","n","toString","call","slice","constructor","name","test","len","arr2","extend","getOwnPropertyNames","reduce","extended","currentValue","newValue","isString","parseSettings","settings","types","split","map","type","trim","absolute","position","parseTypes","none","lines","words","chars","isObject","isNode","input","isLength","isArrayLike","toArray","getTargetElements","elements","getElementById","querySelectorAll","result","element","concat","entries","expando","cache","uid","set","owner","console","warn","id","data","getPrototypeOf","get","remove","clear","cleanup","_ref","_ref2","_ref2$","isRoot","isSplit","toWords","separator","string","replace","rsAstralRange","rsComboMarksRange","rsComboSymbolsRange","rsVarRange","rsAstral","rsCombo","rsFitz","rsModifier","rsNonAstral","rsRegional","rsSurrPair","rsZWJ","reOptMod","rsOptVar","rsOptJoin","join","rsSeq","rsSymbol","reUnicode","RegExp","unicodeRange","reHasUnicode","asciiToArray","hasUnicode","unicodeToArray","match","stringToArray","toChars","createElement","attributes","attribute","rawValue","setAttribute","defaults","splitClass","lineClass","wordClass","charClass","tagName","splitWordsAndChars","textNode","TAG_NAME","VALUE","nodeValue","splitText","createDocumentFragment","WORD","idx","wordElement","characterElementsForCurrentWord","CHAR","characterElement","style","children","isWord","isWordStart","isWordEnd","wordsAndChars","childNodes","display","nextSibling","prevSibling","text","textContent","textAfter","textBefore","child","_split","getPosition","scrollPos","top","offsetTop","offsetParent","_scrollPos","scrollX","scrollY","parentX","parentY","body","parentRect","getBoundingClientRect","x","y","_node$getBoundingClie","width","height","left","unSplitWords","createFragment","repositionAfterSplit","getElementsByTagName","wordsInEachLine","wordsInCurrentLine","lineOffsetY","elementHeight","elementWidth","contentBox","parentElement","nextElementSibling","cs","window","getComputedStyle","align","textAlign","fontSize","parseFloat","lineThreshold","offsetLeft","offsetWidth","offsetHeight","cssWidth","cssHeight","isWordLike","_getPosition","nodeName","wordsInThisLine","lineElement","lineDimensions","wordOrElement","_data$get","Math","max","min","_data$get2","isLine","parentData","isChildOfLineNode","_defaults","SplitType","clearData","setDefaults","options","revert","html","innerHTML","create","split$1","_this","pageXOffset","pageYOffset","_split2","scrollTo","default"],"sources":["C:/Users/aashn/OneDrive/Documents/Aashna/3_PROJECTS/programming/personal-website/node_modules/split-type/dist/index.js"],"sourcesContent":["/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.4\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(function () {\n  function append() {\n    var length = arguments.length;\n\n    for (var i = 0; i < length; i++) {\n      var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n\n  function replaceChildren() {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    if (arguments.length) this.append.apply(this, arguments);\n  }\n\n  function replaceWith() {\n    var parent = this.parentNode;\n\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n\n    var i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n\n    while (i--) {\n      var node = nodes[i];\n\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce(function (extended, key) {\n    var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings() {\n  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  var types;\n\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(function (type) {\n      return String(type).trim();\n    }).filter(function (type) {\n      return /((line)|(word)|(char))/i.test(type);\n    });\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  var types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  var elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n\n  return toArray(elements).reduce(function (result, element) {\n    return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\n  }, []);\n}\n\nvar entries = Object.entries;\n\nvar expando = \"_splittype\";\nvar cache = {};\nvar uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n\n  var id = owner[expando] || (owner[expando] = ++uid);\n  var data = cache[id] || (cache[id] = {});\n\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = _objectSpread2(_objectSpread2({}, data), key);\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n\n  return value;\n}\nfunction get(owner, key) {\n  var id = isObject(owner) ? owner[expando] : null;\n  var data = id && cache[id] || {};\n\n  if (key === undefined) {\n    return data;\n  }\n\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  var id = element && element[expando];\n\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Clear all cached data\n */\n\nfunction clear() {\n  Object.keys(cache).forEach(function (key) {\n    delete cache[key];\n  });\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        id = _ref2[0],\n        _ref2$ = _ref2[1],\n        isRoot = _ref2$.isRoot,\n        isSplit = _ref2$.isSplit;\n\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';\n  var string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nvar rsAstralRange = \"\\\\ud800-\\\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */\n\nvar rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\\\ud83c[\\\\udffb-\\\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}\";\nvar rsSurrPair = \"[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */\n\nvar reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\"\".concat(rsNonAstral).concat(rsCombo, \"?\"), rsCombo, rsRegional, rsSurrPair, rsAstral].join('|'), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nvar reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nvar unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(''), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */\n\n\nfunction toChars(string) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  var element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(function (attribute) {\n    var rawValue = attributes[attribute];\n    var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append.apply(element, _toConsumableArray(toArray(value)));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  var types = parseTypes(settings.types); // the tag name for split text nodes\n\n  var TAG_NAME = settings.tagName; // value of the text node\n\n  var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  var words = [];\n  var chars = [];\n\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n\n  words = toWords(VALUE).reduce(function (result, WORD, idx, arr) {\n    // Let `wordElement` be the wrapped element for the current word\n    var wordElement;\n    var characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(function (CHAR) {\n        var characterElement = createElement(TAG_NAME, {\n          \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [].concat(_toConsumableArray(chars), [characterElement]);\n        return characterElement;\n      });\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n        style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : ''),\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(function (characterElement) {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n\n  textNode.replaceWith(splitText);\n  return {\n    words: words,\n    chars: chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  var type = node.nodeType; // Arrays of split words and characters\n\n  var wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n\n  var childNodes = toArray(node.childNodes);\n\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      var nextSibling = node.nextSibling;\n      var prevSibling = node.previousSibling;\n      var text = node.textContent || '';\n      var textAfter = nextSibling ? nextSibling.textContent : ' ';\n      var textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n\n  return childNodes.reduce(function (result, child) {\n    var _split = split(child, settings),\n        words = _split.words,\n        chars = _split.chars;\n\n    return {\n      words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\n      chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n\n  var parent = node.offsetParent;\n\n  var _scrollPos = _slicedToArray(scrollPos, 2),\n      scrollX = _scrollPos[0],\n      scrollY = _scrollPos[1];\n\n  var parentX = 0;\n  var parentY = 0;\n\n  if (parent && parent !== document.body) {\n    var parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height,\n      x = _node$getBoundingClie.x,\n      y = _node$getBoundingClie.y;\n\n  var top = y + scrollY - parentY;\n  var left = x + scrollX - parentX;\n  return {\n    width: width,\n    height: height,\n    top: top,\n    left: left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(function (child) {\n      return unSplitWords(child);\n    });\n  } else {\n    remove(element);\n    element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\n  }\n}\n\nvar createFragment = function createFragment() {\n  return document.createDocumentFragment();\n};\n\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  var types = parseTypes(settings.types);\n  var TAG_NAME = settings.tagName;\n  var nodes = element.getElementsByTagName('*');\n  var wordsInEachLine = [];\n  var wordsInCurrentLine = [];\n  var lineOffsetY = null;\n  var elementHeight;\n  var elementWidth;\n  var contentBox;\n  var lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  var parent = element.parentElement;\n  var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  var splitText = createFragment(); // get the computed style object for the element\n\n  var cs = window.getComputedStyle(element);\n  var align = cs.textAlign;\n  var fontSize = parseFloat(cs.fontSize);\n  var lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n\n  toArray(nodes).forEach(function (node) {\n    // node is a word element or custom html element\n    var isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    var _getPosition = getPosition(node, isWordLike, settings, scrollPos),\n        width = _getPosition.width,\n        height = _getPosition.height,\n        top = _getPosition.top,\n        left = _getPosition.left; // If element is a `<br>` tag return here\n\n\n    if (/^br$/i.test(node.nodeName)) return;\n\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top: top,\n        left: left,\n        width: width,\n        height: height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(function (wordsInThisLine) {\n      // Create an element to wrap the current line.\n      var lineElement = createElement(TAG_NAME, {\n        \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n        style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n      });\n      set(lineElement, 'isLine', true);\n      var lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach(function (wordOrElement, idx, arr) {\n        var _data$get = get(wordOrElement),\n            isWordEnd = _data$get.isWordEnd,\n            top = _data$get.top,\n            height = _data$get.height;\n\n        var next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n    element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\n\n    toArray(nodes).forEach(function (node) {\n      var _data$get2 = get(node),\n          isLine = _data$get2.isLine,\n          top = _data$get2.top,\n          left = _data$get2.left,\n          width = _data$get2.width,\n          height = _data$get2.height;\n\n      var parentData = get(node.parentElement);\n      var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n\n      node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return lines;\n}\n\nvar _defaults = extend(defaults, {});\n\nvar SplitType = /*#__PURE__*/function () {\n  _createClass(SplitType, null, [{\n    key: \"clearData\",\n\n    /**\n     * CLears all data\n     */\n    value: function clearData() {\n      clear();\n    }\n    /**\n     * The default settings for all splitType instances\n     * @static\n     */\n\n  }, {\n    key: \"setDefaults\",\n\n    /**\n     * Sets the default settings for all SplitType instances.\n     * The provided object will be merged with the existing defaults objects.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @returns {Object} the new default settings\n     * @public\n     * @static\n     * @example\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\n     */\n    value: function setDefaults(options) {\n      _defaults = extend(_defaults, parseSettings(options));\n      return defaults;\n    }\n    /**\n     * Revert target elements to their original html content\n     * Has no effect on that\n     *\n     * @param {any} elements The target elements to revert. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @static\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert(elements) {\n      getTargetElements(elements).forEach(function (element) {\n        var _data$get = get(element),\n            isSplit = _data$get.isSplit,\n            html = _data$get.html,\n            cssWidth = _data$get.cssWidth,\n            cssHeight = _data$get.cssHeight;\n\n        if (isSplit) {\n          element.innerHTML = html;\n          element.style.width = cssWidth || '';\n          element.style.height = cssHeight || '';\n          remove(element);\n        }\n      });\n    }\n    /**\n     * Creates a new SplitType instance\n     * This static method provides a way to create a `SplitType` instance without\n     * using the `new` keyword.\n     *\n     * @param {any} target The target elements to split. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @param {Object} [options] Settings for the SplitType instance\n     * @return {SplitType} the SplitType instance\n     * @static\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(target, options) {\n      return new SplitType(target, options);\n    }\n    /**\n     * Creates a new `SplitType` instance\n     *\n     * @param {any} elements The target elements to split. One of:\n     *  - {string} A css selector\n     *  - {HTMLElement} A single element\n     * -  {NodeList} A NodeList or collection\n     *  - {HTMLElement[]} An array of Elements\n     * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n     * @param {Object} [options] Settings for the SplitType instance\n     */\n\n  }, {\n    key: \"data\",\n\n    /**\n     * The internal data store\n     */\n    get: function get() {\n      return cache;\n    }\n  }, {\n    key: \"defaults\",\n    get: function get() {\n      return _defaults;\n    }\n    /**\n     * Sets the default settings for all SplitType instances.\n     *\n     * Setting `SplitType.defaults` to an object will merge that object with the\n     * existing defaults.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @deprecated\n     * @static\n     * @example\n     * SplitType.defaults = { \"position\": \"absolute\" }\n     */\n    ,\n    set: function set(options) {\n      _defaults = extend(_defaults, parseSettings(options));\n    }\n  }]);\n\n  function SplitType(elements, options) {\n    _classCallCheck(this, SplitType);\n\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  _createClass(SplitType, [{\n    key: \"split\",\n    value: function split$1(options) {\n      var _this = this;\n\n      // Revert target elements (if they are already split)\n      // Note: revert was already called once in the constructor. However, we\n      // need to call it again here so text is reverted when the user manually\n      // calls the `split` method to re-split text.\n      this.revert(); // Store the original html content of each target element\n\n      this.elements.forEach(function (element) {\n        set(element, 'html', element.innerHTML);\n      }); // Create arrays to hold the split lines, words, and characters\n\n      this.lines = [];\n      this.words = [];\n      this.chars = []; // cache vertical scroll position before splitting\n\n      var scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n      if (options !== undefined) {\n        this.settings = extend(this.settings, parseSettings(options));\n      }\n\n      var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n      // @example new SplitType('#target', { types: [] })\n\n      if (types.none) {\n        return;\n      } // Split text in each target element\n\n\n      this.elements.forEach(function (element) {\n        // Add the split text nodes from this element to the arrays of all split\n        // text nodes for this instance.\n        set(element, 'isRoot', true);\n\n        var _split2 = split(element, _this.settings),\n            words = _split2.words,\n            chars = _split2.chars;\n\n        _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\n        _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\n      });\n      this.elements.forEach(function (element) {\n        if (types.lines || _this.settings.absolute) {\n          var lines = repositionAfterSplit(element, _this.settings, scrollPos);\n          _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\n        }\n      }); // Set isSplit to true for the SplitType instance\n\n      this.isSplit = true; // Set scroll position to cached value.\n\n      window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n      cleanup();\n    }\n    /**\n     * Reverts target element(s) back to their original html content\n     * Deletes all stored data associated with the target elements\n     * Resets the properties on the splitType instance\n     *\n     * @public\n     */\n\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      if (this.isSplit) {\n        // Reset instance properties if necessary\n        this.lines = null;\n        this.words = null;\n        this.chars = null;\n        this.isSplit = false;\n      }\n\n      SplitType.revert(this.elements);\n    }\n  }]);\n\n  return SplitType;\n}();\n\nexport { SplitType as default };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,YAAY;EACX,SAASA,MAAMA,CAAA,EAAG;IAChB,IAAIC,MAAM,GAAGC,SAAS,CAACD,MAAM;IAE7B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,EAAEE,CAAC,EAAE,EAAE;MAC/B,IAAIC,IAAI,GAAGD,CAAC,GAAG,CAAC,IAAID,SAAS,CAACD,MAAM,IAAIE,CAAC,GAAGE,SAAS,GAAGH,SAAS,CAACC,CAAC,CAAC;MACpE,IAAIC,IAAI,CAACE,QAAQ,KAAK,CAAC,IAAIF,IAAI,CAACE,QAAQ,KAAK,EAAE,EAAE,IAAI,CAACC,WAAW,CAACH,IAAI,CAAC,CAAC,KAAK,IAAI,CAACG,WAAW,CAACC,QAAQ,CAACC,cAAc,CAACC,MAAM,CAACN,IAAI,CAAC,CAAC,CAAC;IACtI;EACF;EAEA,SAASO,eAAeA,CAAA,EAAG;IACzB,OAAO,IAAI,CAACC,SAAS,EAAE;MACrB,IAAI,CAACC,WAAW,CAAC,IAAI,CAACD,SAAS,CAAC;IAClC;IAEA,IAAIV,SAAS,CAACD,MAAM,EAAE,IAAI,CAACD,MAAM,CAACc,KAAK,CAAC,IAAI,EAAEZ,SAAS,CAAC;EAC1D;EAEA,SAASa,WAAWA,CAAA,EAAG;IACrB,IAAIC,MAAM,GAAG,IAAI,CAACC,UAAU;IAE5B,KAAK,IAAIC,IAAI,GAAGhB,SAAS,CAACD,MAAM,EAAEkB,KAAK,GAAG,IAAIC,KAAK,CAACF,IAAI,CAAC,EAAEG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,IAAI,EAAEG,IAAI,EAAE,EAAE;MACxFF,KAAK,CAACE,IAAI,CAAC,GAAGnB,SAAS,CAACmB,IAAI,CAAC;IAC/B;IAEA,IAAIlB,CAAC,GAAGgB,KAAK,CAAClB,MAAM;IACpB,IAAI,CAACe,MAAM,EAAE;IACb,IAAI,CAACb,CAAC,EAAEa,MAAM,CAACH,WAAW,CAAC,IAAI,CAAC;IAEhC,OAAOV,CAAC,EAAE,EAAE;MACV,IAAIC,IAAI,GAAGe,KAAK,CAAChB,CAAC,CAAC;MAEnB,IAAI,OAAOC,IAAI,KAAK,QAAQ,EAAE;QAC5BA,IAAI,GAAG,IAAI,CAACkB,aAAa,CAACb,cAAc,CAACL,IAAI,CAAC;MAChD,CAAC,MAAM,IAAIA,IAAI,CAACa,UAAU,EAAE;QAC1Bb,IAAI,CAACa,UAAU,CAACJ,WAAW,CAACT,IAAI,CAAC;MACnC;MAEA,IAAI,CAACD,CAAC,EAAE;QACNa,MAAM,CAACO,YAAY,CAACnB,IAAI,EAAE,IAAI,CAAC;MACjC,CAAC,MAAM;QACLY,MAAM,CAACQ,YAAY,CAAC,IAAI,CAACC,eAAe,EAAErB,IAAI,CAAC;MACjD;IACF;EACF;EAEA,IAAI,OAAOsB,OAAO,KAAK,WAAW,EAAE;IAClC,IAAI,CAACA,OAAO,CAACC,SAAS,CAAC3B,MAAM,EAAE;MAC7B0B,OAAO,CAACC,SAAS,CAAC3B,MAAM,GAAGA,MAAM;MACjC4B,gBAAgB,CAACD,SAAS,CAAC3B,MAAM,GAAGA,MAAM;IAC5C;IAEA,IAAI,CAAC0B,OAAO,CAACC,SAAS,CAAChB,eAAe,EAAE;MACtCe,OAAO,CAACC,SAAS,CAAChB,eAAe,GAAGA,eAAe;MACnDiB,gBAAgB,CAACD,SAAS,CAAChB,eAAe,GAAGA,eAAe;IAC9D;IAEA,IAAI,CAACe,OAAO,CAACC,SAAS,CAACZ,WAAW,EAAE;MAClCW,OAAO,CAACC,SAAS,CAACZ,WAAW,GAAGA,WAAW;MAC3Ca,gBAAgB,CAACD,SAAS,CAACZ,WAAW,GAAGA,WAAW;IACtD;EACF;AACF,CAAC,EAAE,CAAC;AAEJ,SAASc,eAAeA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAC9C,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IACtC,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;EAC1D;AACF;AAEA,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,KAAK,EAAE;EACxC,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,KAAK,CAAClC,MAAM,EAAEE,CAAC,EAAE,EAAE;IACrC,IAAIiC,UAAU,GAAGD,KAAK,CAAChC,CAAC,CAAC;IACzBiC,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IACtDD,UAAU,CAACE,YAAY,GAAG,IAAI;IAC9B,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IACrDC,MAAM,CAACC,cAAc,CAACP,MAAM,EAAEE,UAAU,CAACM,GAAG,EAAEN,UAAU,CAAC;EAC3D;AACF;AAEA,SAASO,YAAYA,CAACZ,WAAW,EAAEa,UAAU,EAAEC,WAAW,EAAE;EAC1D,IAAID,UAAU,EAAEX,iBAAiB,CAACF,WAAW,CAACJ,SAAS,EAAEiB,UAAU,CAAC;EACpE,IAAIC,WAAW,EAAEZ,iBAAiB,CAACF,WAAW,EAAEc,WAAW,CAAC;EAC5D,OAAOd,WAAW;AACpB;AAEA,SAASe,eAAeA,CAACC,GAAG,EAAEL,GAAG,EAAEM,KAAK,EAAE;EACxC,IAAIN,GAAG,IAAIK,GAAG,EAAE;IACdP,MAAM,CAACC,cAAc,CAACM,GAAG,EAAEL,GAAG,EAAE;MAC9BM,KAAK,EAAEA,KAAK;MACZX,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE;IACZ,CAAC,CAAC;EACJ,CAAC,MAAM;IACLQ,GAAG,CAACL,GAAG,CAAC,GAAGM,KAAK;EAClB;EAEA,OAAOD,GAAG;AACZ;AAEA,SAASE,OAAOA,CAACC,MAAM,EAAEC,cAAc,EAAE;EACvC,IAAIC,IAAI,GAAGZ,MAAM,CAACY,IAAI,CAACF,MAAM,CAAC;EAE9B,IAAIV,MAAM,CAACa,qBAAqB,EAAE;IAChC,IAAIC,OAAO,GAAGd,MAAM,CAACa,qBAAqB,CAACH,MAAM,CAAC;IAClD,IAAIC,cAAc,EAAEG,OAAO,GAAGA,OAAO,CAACC,MAAM,CAAC,UAAUC,GAAG,EAAE;MAC1D,OAAOhB,MAAM,CAACiB,wBAAwB,CAACP,MAAM,EAAEM,GAAG,CAAC,CAACnB,UAAU;IAChE,CAAC,CAAC;IACFe,IAAI,CAACM,IAAI,CAAC5C,KAAK,CAACsC,IAAI,EAAEE,OAAO,CAAC;EAChC;EAEA,OAAOF,IAAI;AACb;AAEA,SAASO,cAAcA,CAACzB,MAAM,EAAE;EAC9B,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAACD,MAAM,EAAEE,CAAC,EAAE,EAAE;IACzC,IAAIyD,MAAM,GAAG1D,SAAS,CAACC,CAAC,CAAC,IAAI,IAAI,GAAGD,SAAS,CAACC,CAAC,CAAC,GAAG,CAAC,CAAC;IAErD,IAAIA,CAAC,GAAG,CAAC,EAAE;MACT8C,OAAO,CAACT,MAAM,CAACoB,MAAM,CAAC,EAAE,IAAI,CAAC,CAACC,OAAO,CAAC,UAAUnB,GAAG,EAAE;QACnDI,eAAe,CAACZ,MAAM,EAAEQ,GAAG,EAAEkB,MAAM,CAAClB,GAAG,CAAC,CAAC;MAC3C,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIF,MAAM,CAACsB,yBAAyB,EAAE;MAC3CtB,MAAM,CAACuB,gBAAgB,CAAC7B,MAAM,EAAEM,MAAM,CAACsB,yBAAyB,CAACF,MAAM,CAAC,CAAC;IAC3E,CAAC,MAAM;MACLX,OAAO,CAACT,MAAM,CAACoB,MAAM,CAAC,CAAC,CAACC,OAAO,CAAC,UAAUnB,GAAG,EAAE;QAC7CF,MAAM,CAACC,cAAc,CAACP,MAAM,EAAEQ,GAAG,EAAEF,MAAM,CAACiB,wBAAwB,CAACG,MAAM,EAAElB,GAAG,CAAC,CAAC;MAClF,CAAC,CAAC;IACJ;EACF;EAEA,OAAOR,MAAM;AACf;AAEA,SAAS8B,cAAcA,CAACC,GAAG,EAAE9D,CAAC,EAAE;EAC9B,OAAO+D,eAAe,CAACD,GAAG,CAAC,IAAIE,qBAAqB,CAACF,GAAG,EAAE9D,CAAC,CAAC,IAAIiE,2BAA2B,CAACH,GAAG,EAAE9D,CAAC,CAAC,IAAIkE,gBAAgB,CAAC,CAAC;AAC3H;AAEA,SAASC,kBAAkBA,CAACL,GAAG,EAAE;EAC/B,OAAOM,kBAAkB,CAACN,GAAG,CAAC,IAAIO,gBAAgB,CAACP,GAAG,CAAC,IAAIG,2BAA2B,CAACH,GAAG,CAAC,IAAIQ,kBAAkB,CAAC,CAAC;AACrH;AAEA,SAASF,kBAAkBA,CAACN,GAAG,EAAE;EAC/B,IAAI7C,KAAK,CAACsD,OAAO,CAACT,GAAG,CAAC,EAAE,OAAOU,iBAAiB,CAACV,GAAG,CAAC;AACvD;AAEA,SAASC,eAAeA,CAACD,GAAG,EAAE;EAC5B,IAAI7C,KAAK,CAACsD,OAAO,CAACT,GAAG,CAAC,EAAE,OAAOA,GAAG;AACpC;AAEA,SAASO,gBAAgBA,CAACI,IAAI,EAAE;EAC9B,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,QAAQ,IAAItC,MAAM,CAACoC,IAAI,CAAC,EAAE,OAAOxD,KAAK,CAAC2D,IAAI,CAACH,IAAI,CAAC;AAC/F;AAEA,SAAST,qBAAqBA,CAACF,GAAG,EAAE9D,CAAC,EAAE;EACrC,IAAI,OAAO0E,MAAM,KAAK,WAAW,IAAI,EAAEA,MAAM,CAACC,QAAQ,IAAItC,MAAM,CAACyB,GAAG,CAAC,CAAC,EAAE;EACxE,IAAIe,IAAI,GAAG,EAAE;EACb,IAAIC,EAAE,GAAG,IAAI;EACb,IAAIC,EAAE,GAAG,KAAK;EACd,IAAIC,EAAE,GAAG9E,SAAS;EAElB,IAAI;IACF,KAAK,IAAI+E,EAAE,GAAGnB,GAAG,CAACY,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC,EAAEO,EAAE,EAAE,EAAEJ,EAAE,GAAG,CAACI,EAAE,GAAGD,EAAE,CAACE,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC,EAAEN,EAAE,GAAG,IAAI,EAAE;MAClFD,IAAI,CAACtB,IAAI,CAAC2B,EAAE,CAACrC,KAAK,CAAC;MAEnB,IAAI7C,CAAC,IAAI6E,IAAI,CAAC/E,MAAM,KAAKE,CAAC,EAAE;IAC9B;EACF,CAAC,CAAC,OAAOqF,GAAG,EAAE;IACZN,EAAE,GAAG,IAAI;IACTC,EAAE,GAAGK,GAAG;EACV,CAAC,SAAS;IACR,IAAI;MACF,IAAI,CAACP,EAAE,IAAIG,EAAE,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAEA,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;IACjD,CAAC,SAAS;MACR,IAAIF,EAAE,EAAE,MAAMC,EAAE;IAClB;EACF;EAEA,OAAOH,IAAI;AACb;AAEA,SAASZ,2BAA2BA,CAACqB,CAAC,EAAEC,MAAM,EAAE;EAC9C,IAAI,CAACD,CAAC,EAAE;EACR,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOd,iBAAiB,CAACc,CAAC,EAAEC,MAAM,CAAC;EAC9D,IAAIC,CAAC,GAAGnD,MAAM,CAACb,SAAS,CAACiE,QAAQ,CAACC,IAAI,CAACJ,CAAC,CAAC,CAACK,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACtD,IAAIH,CAAC,KAAK,QAAQ,IAAIF,CAAC,CAACM,WAAW,EAAEJ,CAAC,GAAGF,CAAC,CAACM,WAAW,CAACC,IAAI;EAC3D,IAAIL,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOvE,KAAK,CAAC2D,IAAI,CAACU,CAAC,CAAC;EACpD,IAAIE,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACM,IAAI,CAACN,CAAC,CAAC,EAAE,OAAOhB,iBAAiB,CAACc,CAAC,EAAEC,MAAM,CAAC;AAClH;AAEA,SAASf,iBAAiBA,CAACV,GAAG,EAAEiC,GAAG,EAAE;EACnC,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGjC,GAAG,CAAChE,MAAM,EAAEiG,GAAG,GAAGjC,GAAG,CAAChE,MAAM;EAErD,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEgG,IAAI,GAAG,IAAI/E,KAAK,CAAC8E,GAAG,CAAC,EAAE/F,CAAC,GAAG+F,GAAG,EAAE/F,CAAC,EAAE,EAAEgG,IAAI,CAAChG,CAAC,CAAC,GAAG8D,GAAG,CAAC9D,CAAC,CAAC;EAErE,OAAOgG,IAAI;AACb;AAEA,SAAS1B,kBAAkBA,CAAA,EAAG;EAC5B,MAAM,IAAIzC,SAAS,CAAC,sIAAsI,CAAC;AAC7J;AAEA,SAASqC,gBAAgBA,CAAA,EAAG;EAC1B,MAAM,IAAIrC,SAAS,CAAC,2IAA2I,CAAC;AAClK;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoE,MAAMA,CAAClE,MAAM,EAAEgB,MAAM,EAAE;EAC9B,OAAOV,MAAM,CAAC6D,mBAAmB,CAAC7D,MAAM,CAACN,MAAM,CAAC,CAAC,CAACoE,MAAM,CAAC,UAAUC,QAAQ,EAAE7D,GAAG,EAAE;IAChF,IAAI8D,YAAY,GAAGhE,MAAM,CAACiB,wBAAwB,CAACjB,MAAM,CAACN,MAAM,CAAC,EAAEQ,GAAG,CAAC;IACvE,IAAI+D,QAAQ,GAAGjE,MAAM,CAACiB,wBAAwB,CAACjB,MAAM,CAACU,MAAM,CAAC,EAAER,GAAG,CAAC;IACnE,OAAOF,MAAM,CAACC,cAAc,CAAC8D,QAAQ,EAAE7D,GAAG,EAAE+D,QAAQ,IAAID,YAAY,CAAC;EACvE,CAAC,EAAE,CAAC,CAAC,CAAC;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,QAAQA,CAAC1D,KAAK,EAAE;EACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ;AAClC;AAEA,SAAS0B,OAAOA,CAAC1B,KAAK,EAAE;EACtB,OAAO5B,KAAK,CAACsD,OAAO,CAAC1B,KAAK,CAAC;AAC7B;;AAEA;AACA;AACA;;AAEA,SAAS2D,aAAaA,CAAA,EAAG;EACvB,IAAIC,QAAQ,GAAG1G,SAAS,CAACD,MAAM,GAAG,CAAC,IAAIC,SAAS,CAAC,CAAC,CAAC,KAAKG,SAAS,GAAGH,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACrF,IAAIgD,MAAM,GAAGkD,MAAM,CAACQ,QAAQ,CAAC,CAAC,CAAC;EAC/B;EACA;EACA;;EAEA,IAAIC,KAAK;EAET,IAAI3D,MAAM,CAAC2D,KAAK,KAAKxG,SAAS,EAAE;IAC9BwG,KAAK,GAAG3D,MAAM,CAAC2D,KAAK;EACtB,CAAC,MAAM,IAAI3D,MAAM,CAAC4D,KAAK,KAAKzG,SAAS,EAAE;IACrCwG,KAAK,GAAG3D,MAAM,CAAC4D,KAAK;EACtB;EAEA,IAAID,KAAK,KAAKxG,SAAS,EAAE;IACvB6C,MAAM,CAAC2D,KAAK,GAAG,CAACH,QAAQ,CAACG,KAAK,CAAC,IAAInC,OAAO,CAACmC,KAAK,CAAC,GAAGnG,MAAM,CAACmG,KAAK,CAAC,GAAG,EAAE,EAAEC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,UAAUC,IAAI,EAAE;MACrG,OAAOtG,MAAM,CAACsG,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC1D,MAAM,CAAC,UAAUyD,IAAI,EAAE;MACxB,OAAO,yBAAyB,CAACf,IAAI,CAACe,IAAI,CAAC;IAC7C,CAAC,CAAC;EACJ,CAAC,CAAC;;EAGF,IAAI9D,MAAM,CAACgE,QAAQ,IAAIhE,MAAM,CAACiE,QAAQ,EAAE;IACtCjE,MAAM,CAACgE,QAAQ,GAAGhE,MAAM,CAACgE,QAAQ,IAAI,UAAU,CAACjB,IAAI,CAACW,QAAQ,CAACO,QAAQ,CAAC;EACzE;EAEA,OAAOjE,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASkE,UAAUA,CAACpE,KAAK,EAAE;EACzB,IAAI6D,KAAK,GAAGH,QAAQ,CAAC1D,KAAK,CAAC,IAAI0B,OAAO,CAAC1B,KAAK,CAAC,GAAGtC,MAAM,CAACsC,KAAK,CAAC,GAAG,EAAE;EAClE,OAAO;IACLqE,IAAI,EAAE,CAACR,KAAK;IACZS,KAAK,EAAE,OAAO,CAACrB,IAAI,CAACY,KAAK,CAAC;IAC1BU,KAAK,EAAE,OAAO,CAACtB,IAAI,CAACY,KAAK,CAAC;IAC1BW,KAAK,EAAE,OAAO,CAACvB,IAAI,CAACY,KAAK;EAC3B,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASY,QAAQA,CAACzE,KAAK,EAAE;EACvB,OAAOA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS0E,MAAMA,CAACC,KAAK,EAAE;EACrB,OAAOF,QAAQ,CAACE,KAAK,CAAC,IAAI,YAAY,CAAC1B,IAAI,CAAC0B,KAAK,CAACrH,QAAQ,CAAC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASsH,QAAQA,CAAC5E,KAAK,EAAE;EACvB,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,GAAG,CAAC,CAAC,IAAIA,KAAK,GAAG,CAAC,KAAK,CAAC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAAS6E,WAAWA,CAAC7E,KAAK,EAAE;EAC1B,OAAOyE,QAAQ,CAACzE,KAAK,CAAC,IAAI4E,QAAQ,CAAC5E,KAAK,CAAC/C,MAAM,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS6H,OAAOA,CAAC9E,KAAK,EAAE;EACtB,IAAI0B,OAAO,CAAC1B,KAAK,CAAC,EAAE,OAAOA,KAAK;EAChC,IAAIA,KAAK,IAAI,IAAI,EAAE,OAAO,EAAE;EAC5B,OAAO6E,WAAW,CAAC7E,KAAK,CAAC,GAAG5B,KAAK,CAACO,SAAS,CAACmE,KAAK,CAACD,IAAI,CAAC7C,KAAK,CAAC,GAAG,CAACA,KAAK,CAAC;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS+E,iBAAiBA,CAAC7F,MAAM,EAAE;EACjC,IAAI8F,QAAQ,GAAG9F,MAAM,CAAC,CAAC;;EAEvB,IAAIwE,QAAQ,CAACxE,MAAM,CAAC,EAAE;IACpB,IAAI,eAAe,CAAC+D,IAAI,CAAC/D,MAAM,CAAC+E,IAAI,CAAC,CAAC,CAAC,EAAE;MACvC;MACAe,QAAQ,GAAGxH,QAAQ,CAACyH,cAAc,CAAC/F,MAAM,CAAC+E,IAAI,CAAC,CAAC,CAACnB,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5D,CAAC,MAAM;MACL;MACAkC,QAAQ,GAAGxH,QAAQ,CAAC0H,gBAAgB,CAAChG,MAAM,CAAC;IAC9C;EACF,CAAC,CAAC;;EAGF,OAAO4F,OAAO,CAACE,QAAQ,CAAC,CAAC1B,MAAM,CAAC,UAAU6B,MAAM,EAAEC,OAAO,EAAE;IACzD,OAAO,EAAE,CAACC,MAAM,CAAC/D,kBAAkB,CAAC6D,MAAM,CAAC,EAAE7D,kBAAkB,CAACwD,OAAO,CAACM,OAAO,CAAC,CAAC7E,MAAM,CAACmE,MAAM,CAAC,CAAC,CAAC;EACnG,CAAC,EAAE,EAAE,CAAC;AACR;AAEA,IAAIY,OAAO,GAAG9F,MAAM,CAAC8F,OAAO;AAE5B,IAAIC,OAAO,GAAG,YAAY;AAC1B,IAAIC,KAAK,GAAG,CAAC,CAAC;AACd,IAAIC,GAAG,GAAG,CAAC;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,GAAGA,CAACC,KAAK,EAAEjG,GAAG,EAAEM,KAAK,EAAE;EAC9B,IAAI,CAACyE,QAAQ,CAACkB,KAAK,CAAC,EAAE;IACpBC,OAAO,CAACC,IAAI,CAAC,mCAAmC,CAAC;IACjD,OAAO,IAAI;EACb;EAEA,IAAIC,EAAE,GAAGH,KAAK,CAACJ,OAAO,CAAC,KAAKI,KAAK,CAACJ,OAAO,CAAC,GAAG,EAAEE,GAAG,CAAC;EACnD,IAAIM,IAAI,GAAGP,KAAK,CAACM,EAAE,CAAC,KAAKN,KAAK,CAACM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;EAExC,IAAI9F,KAAK,KAAK3C,SAAS,EAAE;IACvB,IAAI,CAAC,CAACqC,GAAG,IAAIF,MAAM,CAACwG,cAAc,CAACtG,GAAG,CAAC,KAAKF,MAAM,CAACb,SAAS,EAAE;MAC5D6G,KAAK,CAACM,EAAE,CAAC,GAAGnF,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEoF,IAAI,CAAC,EAAErG,GAAG,CAAC;IAC3D;EACF,CAAC,MAAM,IAAIA,GAAG,KAAKrC,SAAS,EAAE;IAC5B0I,IAAI,CAACrG,GAAG,CAAC,GAAGM,KAAK;EACnB;EAEA,OAAOA,KAAK;AACd;AACA,SAASiG,GAAGA,CAACN,KAAK,EAAEjG,GAAG,EAAE;EACvB,IAAIoG,EAAE,GAAGrB,QAAQ,CAACkB,KAAK,CAAC,GAAGA,KAAK,CAACJ,OAAO,CAAC,GAAG,IAAI;EAChD,IAAIQ,IAAI,GAAGD,EAAE,IAAIN,KAAK,CAACM,EAAE,CAAC,IAAI,CAAC,CAAC;EAEhC,IAAIpG,GAAG,KAAKrC,SAAS,EAAE;IACrB,OAAO0I,IAAI;EACb;EAEA,OAAOA,IAAI,CAACrG,GAAG,CAAC;AAClB;AACA;AACA;AACA;;AAEA,SAASwG,MAAMA,CAACd,OAAO,EAAE;EACvB,IAAIU,EAAE,GAAGV,OAAO,IAAIA,OAAO,CAACG,OAAO,CAAC;EAEpC,IAAIO,EAAE,EAAE;IACN,OAAOV,OAAO,CAACU,EAAE,CAAC;IAClB,OAAON,KAAK,CAACM,EAAE,CAAC;EAClB;AACF;AACA;AACA;AACA;;AAEA,SAASK,KAAKA,CAAA,EAAG;EACf3G,MAAM,CAACY,IAAI,CAACoF,KAAK,CAAC,CAAC3E,OAAO,CAAC,UAAUnB,GAAG,EAAE;IACxC,OAAO8F,KAAK,CAAC9F,GAAG,CAAC;EACnB,CAAC,CAAC;AACJ;AACA;AACA;AACA;;AAEA,SAAS0G,OAAOA,CAAA,EAAG;EACjBd,OAAO,CAACE,KAAK,CAAC,CAAC3E,OAAO,CAAC,UAAUwF,IAAI,EAAE;IACrC,IAAIC,KAAK,GAAGtF,cAAc,CAACqF,IAAI,EAAE,CAAC,CAAC;MAC/BP,EAAE,GAAGQ,KAAK,CAAC,CAAC,CAAC;MACbC,MAAM,GAAGD,KAAK,CAAC,CAAC,CAAC;MACjBE,MAAM,GAAGD,MAAM,CAACC,MAAM;MACtBC,OAAO,GAAGF,MAAM,CAACE,OAAO;IAE5B,IAAI,CAACD,MAAM,IAAI,CAACC,OAAO,EAAE;MACvBjB,KAAK,CAACM,EAAE,CAAC,GAAG,IAAI;MAChB,OAAON,KAAK,CAACM,EAAE,CAAC;IAClB;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,OAAOA,CAAC1G,KAAK,EAAE;EACtB,IAAI2G,SAAS,GAAGzJ,SAAS,CAACD,MAAM,GAAG,CAAC,IAAIC,SAAS,CAAC,CAAC,CAAC,KAAKG,SAAS,GAAGH,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG;EACvF,IAAI0J,MAAM,GAAG5G,KAAK,GAAGtC,MAAM,CAACsC,KAAK,CAAC,GAAG,EAAE;EACvC,OAAO4G,MAAM,CAAC3C,IAAI,CAAC,CAAC,CAAC4C,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC/C,KAAK,CAAC6C,SAAS,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,aAAa,GAAG,iBAAiB;AACrC,IAAIC,iBAAiB,GAAG,gCAAgC;AACxD,IAAIC,mBAAmB,GAAG,iBAAiB;AAC3C,IAAIC,UAAU,GAAG,gBAAgB;AACjC;;AAEA,IAAIC,QAAQ,GAAG,GAAG,CAAC7B,MAAM,CAACyB,aAAa,EAAE,GAAG,CAAC;AAC7C,IAAIK,OAAO,GAAG,GAAG,CAAC9B,MAAM,CAAC0B,iBAAiB,CAAC,CAAC1B,MAAM,CAAC2B,mBAAmB,EAAE,GAAG,CAAC;AAC5E,IAAII,MAAM,GAAG,0BAA0B;AACvC,IAAIC,UAAU,GAAG,KAAK,CAAChC,MAAM,CAAC8B,OAAO,EAAE,GAAG,CAAC,CAAC9B,MAAM,CAAC+B,MAAM,EAAE,GAAG,CAAC;AAC/D,IAAIE,WAAW,GAAG,IAAI,CAACjC,MAAM,CAACyB,aAAa,EAAE,GAAG,CAAC;AACjD,IAAIS,UAAU,GAAG,iCAAiC;AAClD,IAAIC,UAAU,GAAG,oCAAoC;AACrD,IAAIC,KAAK,GAAG,SAAS;AACrB;;AAEA,IAAIC,QAAQ,GAAG,EAAE,CAACrC,MAAM,CAACgC,UAAU,EAAE,GAAG,CAAC;AACzC,IAAIM,QAAQ,GAAG,GAAG,CAACtC,MAAM,CAAC4B,UAAU,EAAE,IAAI,CAAC;AAC3C,IAAIW,SAAS,GAAG,KAAK,GAAGH,KAAK,GAAG,KAAK,GAAG,CAACH,WAAW,EAAEC,UAAU,EAAEC,UAAU,CAAC,CAACK,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,GAAGF,QAAQ,GAAGD,QAAQ,GAAG,IAAI;AAC1H,IAAII,KAAK,GAAGH,QAAQ,GAAGD,QAAQ,GAAGE,SAAS;AAC3C,IAAIG,QAAQ,GAAG,KAAK,CAAC1C,MAAM,CAAC,CAAC,EAAE,CAACA,MAAM,CAACiC,WAAW,CAAC,CAACjC,MAAM,CAAC8B,OAAO,EAAE,GAAG,CAAC,EAAEA,OAAO,EAAEI,UAAU,EAAEC,UAAU,EAAEN,QAAQ,CAAC,CAACW,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC;AACtI;;AAEA,IAAIG,SAAS,GAAGC,MAAM,CAAC,EAAE,CAAC5C,MAAM,CAAC+B,MAAM,EAAE,KAAK,CAAC,CAAC/B,MAAM,CAAC+B,MAAM,EAAE,IAAI,CAAC,CAAC/B,MAAM,CAAC0C,QAAQ,CAAC,CAAC1C,MAAM,CAACyC,KAAK,CAAC,EAAE,GAAG,CAAC;AACzG;;AAEA,IAAII,YAAY,GAAG,CAACT,KAAK,EAAEX,aAAa,EAAEC,iBAAiB,EAAEC,mBAAmB,EAAEC,UAAU,CAAC;AAC7F,IAAIkB,YAAY,GAAGF,MAAM,CAAC,GAAG,CAAC5C,MAAM,CAAC6C,YAAY,CAACL,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASO,YAAYA,CAACxB,MAAM,EAAE;EAC5B,OAAOA,MAAM,CAAC9C,KAAK,CAAC,EAAE,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASuE,UAAUA,CAACzB,MAAM,EAAE;EAC1B,OAAOuB,YAAY,CAAClF,IAAI,CAAC2D,MAAM,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAAS0B,cAAcA,CAAC1B,MAAM,EAAE;EAC9B,OAAOA,MAAM,CAAC2B,KAAK,CAACP,SAAS,CAAC,IAAI,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASQ,aAAaA,CAAC5B,MAAM,EAAE;EAC7B,OAAOyB,UAAU,CAACzB,MAAM,CAAC,GAAG0B,cAAc,CAAC1B,MAAM,CAAC,GAAGwB,YAAY,CAACxB,MAAM,CAAC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAShE,QAAQA,CAAC5C,KAAK,EAAE;EACvB,OAAOA,KAAK,IAAI,IAAI,GAAG,EAAE,GAAGtC,MAAM,CAACsC,KAAK,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAASyI,OAAOA,CAAC7B,MAAM,EAAE;EACvB,IAAID,SAAS,GAAGzJ,SAAS,CAACD,MAAM,GAAG,CAAC,IAAIC,SAAS,CAAC,CAAC,CAAC,KAAKG,SAAS,GAAGH,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EACtF0J,MAAM,GAAGhE,QAAQ,CAACgE,MAAM,CAAC;EAEzB,IAAIA,MAAM,IAAIlD,QAAQ,CAACkD,MAAM,CAAC,EAAE;IAC9B,IAAI,CAACD,SAAS,IAAI0B,UAAU,CAACzB,MAAM,CAAC,EAAE;MACpC,OAAO4B,aAAa,CAAC5B,MAAM,CAAC;IAC9B;EACF;EAEA,OAAOA,MAAM,CAAC9C,KAAK,CAAC6C,SAAS,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS+B,aAAaA,CAAC1F,IAAI,EAAE2F,UAAU,EAAE;EACvC,IAAIvD,OAAO,GAAG5H,QAAQ,CAACkL,aAAa,CAAC1F,IAAI,CAAC;EAE1C,IAAI,CAAC2F,UAAU,EAAE;IACf;IACA;IACA,OAAOvD,OAAO;EAChB;EAEA5F,MAAM,CAACY,IAAI,CAACuI,UAAU,CAAC,CAAC9H,OAAO,CAAC,UAAU+H,SAAS,EAAE;IACnD,IAAIC,QAAQ,GAAGF,UAAU,CAACC,SAAS,CAAC;IACpC,IAAI5I,KAAK,GAAG0D,QAAQ,CAACmF,QAAQ,CAAC,GAAGA,QAAQ,CAAC5E,IAAI,CAAC,CAAC,GAAG4E,QAAQ,CAAC,CAAC;;IAE7D,IAAI7I,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,EAAE,EAAE;IAEpC,IAAI4I,SAAS,KAAK,UAAU,EAAE;MAC5B;MACAxD,OAAO,CAACpI,MAAM,CAACc,KAAK,CAACsH,OAAO,EAAE9D,kBAAkB,CAACwD,OAAO,CAAC9E,KAAK,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM;MACL;MACAoF,OAAO,CAAC0D,YAAY,CAACF,SAAS,EAAE5I,KAAK,CAAC;IACxC;EACF,CAAC,CAAC;EACF,OAAOoF,OAAO;AAChB;AAEA,IAAI2D,QAAQ,GAAG;EACbC,UAAU,EAAE,EAAE;EACdC,SAAS,EAAE,MAAM;EACjBC,SAAS,EAAE,MAAM;EACjBC,SAAS,EAAE,MAAM;EACjBtF,KAAK,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC;EAClCK,QAAQ,EAAE,KAAK;EACfkF,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,kBAAkBA,CAACC,QAAQ,EAAE1F,QAAQ,EAAE;EAC9CA,QAAQ,GAAGR,MAAM,CAAC2F,QAAQ,EAAEnF,QAAQ,CAAC,CAAC,CAAC;;EAEvC,IAAIC,KAAK,GAAGO,UAAU,CAACR,QAAQ,CAACC,KAAK,CAAC,CAAC,CAAC;;EAExC,IAAI0F,QAAQ,GAAG3F,QAAQ,CAACwF,OAAO,CAAC,CAAC;;EAEjC,IAAII,KAAK,GAAGF,QAAQ,CAACG,SAAS,CAAC,CAAC;;EAEhC,IAAIC,SAAS,GAAGlM,QAAQ,CAACmM,sBAAsB,CAAC,CAAC,CAAC,CAAC;;EAEnD,IAAIpF,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,GAAG,EAAE;EAEd,IAAI,KAAK,CAACvB,IAAI,CAACuG,KAAK,CAAC,EAAE;IACrBE,SAAS,CAAC1M,MAAM,CAAC,GAAG,CAAC;EACvB,CAAC,CAAC;;EAGFuH,KAAK,GAAGmC,OAAO,CAAC8C,KAAK,CAAC,CAAClG,MAAM,CAAC,UAAU6B,MAAM,EAAEyE,IAAI,EAAEC,GAAG,EAAE5I,GAAG,EAAE;IAC9D;IACA,IAAI6I,WAAW;IACf,IAAIC,+BAA+B,CAAC,CAAC;;IAErC,IAAIlG,KAAK,CAACW,KAAK,EAAE;MACf;MACAuF,+BAA+B,GAAGtB,OAAO,CAACmB,IAAI,CAAC,CAAC7F,GAAG,CAAC,UAAUiG,IAAI,EAAE;QAClE,IAAIC,gBAAgB,GAAGvB,aAAa,CAACa,QAAQ,EAAE;UAC7C,OAAO,EAAE,EAAE,CAAClE,MAAM,CAACzB,QAAQ,CAACoF,UAAU,EAAE,GAAG,CAAC,CAAC3D,MAAM,CAACzB,QAAQ,CAACuF,SAAS,CAAC;UACvEe,KAAK,EAAE,wBAAwB;UAC/BC,QAAQ,EAAEH;QACZ,CAAC,CAAC;QACFtE,GAAG,CAACuE,gBAAgB,EAAE,QAAQ,EAAE,IAAI,CAAC;QACrCzF,KAAK,GAAG,EAAE,CAACa,MAAM,CAAC/D,kBAAkB,CAACkD,KAAK,CAAC,EAAE,CAACyF,gBAAgB,CAAC,CAAC;QAChE,OAAOA,gBAAgB;MACzB,CAAC,CAAC;IACJ,CAAC,CAAC;;IAGF,IAAIpG,KAAK,CAACU,KAAK,IAAIV,KAAK,CAACS,KAAK,EAAE;MAC9B;MACA;MACA;MACA;MACA;MACAwF,WAAW,GAAGpB,aAAa,CAACa,QAAQ,EAAE;QACpC,OAAO,EAAE,EAAE,CAAClE,MAAM,CAACzB,QAAQ,CAACsF,SAAS,EAAE,GAAG,CAAC,CAAC7D,MAAM,CAACzB,QAAQ,CAACoF,UAAU,CAAC;QACvEkB,KAAK,EAAE,yBAAyB,CAAC7E,MAAM,CAACxB,KAAK,CAACU,KAAK,IAAIX,QAAQ,CAACM,QAAQ,GAAG,qBAAqB,GAAG,EAAE,CAAC;QACtGiG,QAAQ,EAAEtG,KAAK,CAACW,KAAK,GAAGuF,+BAA+B,GAAGH;MAC5D,CAAC,CAAC;MACFlE,GAAG,CAACoE,WAAW,EAAE;QACfM,MAAM,EAAE,IAAI;QACZC,WAAW,EAAE,IAAI;QACjBC,SAAS,EAAE;MACb,CAAC,CAAC;MACFZ,SAAS,CAACnM,WAAW,CAACuM,WAAW,CAAC;IACpC,CAAC,MAAM;MACL;MACA;MACAC,+BAA+B,CAAClJ,OAAO,CAAC,UAAUoJ,gBAAgB,EAAE;QAClEP,SAAS,CAACnM,WAAW,CAAC0M,gBAAgB,CAAC;MACzC,CAAC,CAAC;IACJ;IAEA,IAAIJ,GAAG,GAAG5I,GAAG,CAAChE,MAAM,GAAG,CAAC,EAAE;MACxB;MACAyM,SAAS,CAAC1M,MAAM,CAAC,GAAG,CAAC;IACvB,CAAC,CAAC;;IAGF,OAAO6G,KAAK,CAACU,KAAK,GAAGY,MAAM,CAACE,MAAM,CAACyE,WAAW,CAAC,GAAG3E,MAAM;EAC1D,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EACR;;EAEA,IAAI,KAAK,CAAClC,IAAI,CAACuG,KAAK,CAAC,EAAE;IACrBE,SAAS,CAAC1M,MAAM,CAAC,GAAG,CAAC;EACvB;EAEAsM,QAAQ,CAACvL,WAAW,CAAC2L,SAAS,CAAC;EAC/B,OAAO;IACLnF,KAAK,EAAEA,KAAK;IACZC,KAAK,EAAEA;EACT,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASV,KAAKA,CAAC1G,IAAI,EAAEwG,QAAQ,EAAE;EAC7B,IAAII,IAAI,GAAG5G,IAAI,CAACE,QAAQ,CAAC,CAAC;;EAE1B,IAAIiN,aAAa,GAAG;IAClBhG,KAAK,EAAE,EAAE;IACTC,KAAK,EAAE;EACT,CAAC,CAAC,CAAC;;EAEH,IAAI,CAAC,UAAU,CAACvB,IAAI,CAACe,IAAI,CAAC,EAAE;IAC1B,OAAOuG,aAAa;EACtB,CAAC,CAAC;EACF;EACA;;EAGA,IAAIvG,IAAI,KAAK,CAAC,IAAI,IAAI,CAACf,IAAI,CAAC7F,IAAI,CAACqM,SAAS,CAAC,EAAE;IAC3C,OAAOJ,kBAAkB,CAACjM,IAAI,EAAEwG,QAAQ,CAAC;EAC3C,CAAC,CAAC;EACF;EACA;;EAGA,IAAI4G,UAAU,GAAG1F,OAAO,CAAC1H,IAAI,CAACoN,UAAU,CAAC;EAEzC,IAAIA,UAAU,CAACvN,MAAM,EAAE;IACrByI,GAAG,CAACtI,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;;IAE5B,IAAI,CAAC6I,GAAG,CAAC7I,IAAI,CAAC,CAACoJ,MAAM,EAAE;MACrBpJ,IAAI,CAAC8M,KAAK,CAACO,OAAO,GAAG,cAAc;MACnCrN,IAAI,CAAC8M,KAAK,CAAC/F,QAAQ,GAAG,UAAU,CAAC,CAAC;MAClC;MACA;MACA;MACA;MACA;;MAEA,IAAIuG,WAAW,GAAGtN,IAAI,CAACsN,WAAW;MAClC,IAAIC,WAAW,GAAGvN,IAAI,CAACqB,eAAe;MACtC,IAAImM,IAAI,GAAGxN,IAAI,CAACyN,WAAW,IAAI,EAAE;MACjC,IAAIC,SAAS,GAAGJ,WAAW,GAAGA,WAAW,CAACG,WAAW,GAAG,GAAG;MAC3D,IAAIE,UAAU,GAAGJ,WAAW,GAAGA,WAAW,CAACE,WAAW,GAAG,GAAG;MAC5DnF,GAAG,CAACtI,IAAI,EAAE;QACRkN,SAAS,EAAE,KAAK,CAACrH,IAAI,CAAC2H,IAAI,CAAC,IAAI,KAAK,CAAC3H,IAAI,CAAC6H,SAAS,CAAC;QACpDT,WAAW,EAAE,KAAK,CAACpH,IAAI,CAAC2H,IAAI,CAAC,IAAI,KAAK,CAAC3H,IAAI,CAAC8H,UAAU;MACxD,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF;;EAGA,OAAOP,UAAU,CAAClH,MAAM,CAAC,UAAU6B,MAAM,EAAE6F,KAAK,EAAE;IAChD,IAAIC,MAAM,GAAGnH,KAAK,CAACkH,KAAK,EAAEpH,QAAQ,CAAC;MAC/BW,KAAK,GAAG0G,MAAM,CAAC1G,KAAK;MACpBC,KAAK,GAAGyG,MAAM,CAACzG,KAAK;IAExB,OAAO;MACLD,KAAK,EAAE,EAAE,CAACc,MAAM,CAAC/D,kBAAkB,CAAC6D,MAAM,CAACZ,KAAK,CAAC,EAAEjD,kBAAkB,CAACiD,KAAK,CAAC,CAAC;MAC7EC,KAAK,EAAE,EAAE,CAACa,MAAM,CAAC/D,kBAAkB,CAAC6D,MAAM,CAACX,KAAK,CAAC,EAAElD,kBAAkB,CAACkD,KAAK,CAAC;IAC9E,CAAC;EACH,CAAC,EAAE+F,aAAa,CAAC;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,WAAWA,CAAC9N,IAAI,EAAEgN,MAAM,EAAExG,QAAQ,EAAEuH,SAAS,EAAE;EACtD,IAAI,CAACvH,QAAQ,CAACM,QAAQ,EAAE;IACtB,OAAO;MACLkH,GAAG,EAAEhB,MAAM,GAAGhN,IAAI,CAACiO,SAAS,GAAG;IACjC,CAAC;EACH;EAEA,IAAIrN,MAAM,GAAGZ,IAAI,CAACkO,YAAY;EAE9B,IAAIC,UAAU,GAAGvK,cAAc,CAACmK,SAAS,EAAE,CAAC,CAAC;IACzCK,OAAO,GAAGD,UAAU,CAAC,CAAC,CAAC;IACvBE,OAAO,GAAGF,UAAU,CAAC,CAAC,CAAC;EAE3B,IAAIG,OAAO,GAAG,CAAC;EACf,IAAIC,OAAO,GAAG,CAAC;EAEf,IAAI3N,MAAM,IAAIA,MAAM,KAAKR,QAAQ,CAACoO,IAAI,EAAE;IACtC,IAAIC,UAAU,GAAG7N,MAAM,CAAC8N,qBAAqB,CAAC,CAAC;IAC/CJ,OAAO,GAAGG,UAAU,CAACE,CAAC,GAAGP,OAAO;IAChCG,OAAO,GAAGE,UAAU,CAACG,CAAC,GAAGP,OAAO;EAClC;EAEA,IAAIQ,qBAAqB,GAAG7O,IAAI,CAAC0O,qBAAqB,CAAC,CAAC;IACpDI,KAAK,GAAGD,qBAAqB,CAACC,KAAK;IACnCC,MAAM,GAAGF,qBAAqB,CAACE,MAAM;IACrCJ,CAAC,GAAGE,qBAAqB,CAACF,CAAC;IAC3BC,CAAC,GAAGC,qBAAqB,CAACD,CAAC;EAE/B,IAAIZ,GAAG,GAAGY,CAAC,GAAGP,OAAO,GAAGE,OAAO;EAC/B,IAAIS,IAAI,GAAGL,CAAC,GAAGP,OAAO,GAAGE,OAAO;EAChC,OAAO;IACLQ,KAAK,EAAEA,KAAK;IACZC,MAAM,EAAEA,MAAM;IACdf,GAAG,EAAEA,GAAG;IACRgB,IAAI,EAAEA;EACR,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,YAAYA,CAACjH,OAAO,EAAE;EAC7B,IAAI,CAACa,GAAG,CAACb,OAAO,CAAC,CAACgF,MAAM,EAAE;IACxBtF,OAAO,CAACM,OAAO,CAAC+E,QAAQ,CAAC,CAACtJ,OAAO,CAAC,UAAUmK,KAAK,EAAE;MACjD,OAAOqB,YAAY,CAACrB,KAAK,CAAC;IAC5B,CAAC,CAAC;EACJ,CAAC,MAAM;IACL9E,MAAM,CAACd,OAAO,CAAC;IACfA,OAAO,CAACrH,WAAW,CAACD,KAAK,CAACsH,OAAO,EAAE9D,kBAAkB,CAAC8D,OAAO,CAACoF,UAAU,CAAC,CAAC;EAC5E;AACF;AAEA,IAAI8B,cAAc,GAAG,SAASA,cAAcA,CAAA,EAAG;EAC7C,OAAO9O,QAAQ,CAACmM,sBAAsB,CAAC,CAAC;AAC1C,CAAC;AAED,SAAS4C,oBAAoBA,CAACnH,OAAO,EAAExB,QAAQ,EAAEuH,SAAS,EAAE;EAC1D,IAAItH,KAAK,GAAGO,UAAU,CAACR,QAAQ,CAACC,KAAK,CAAC;EACtC,IAAI0F,QAAQ,GAAG3F,QAAQ,CAACwF,OAAO;EAC/B,IAAIjL,KAAK,GAAGiH,OAAO,CAACoH,oBAAoB,CAAC,GAAG,CAAC;EAC7C,IAAIC,eAAe,GAAG,EAAE;EACxB,IAAIC,kBAAkB,GAAG,EAAE;EAC3B,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,aAAa;EACjB,IAAIC,YAAY;EAChB,IAAIC,UAAU;EACd,IAAIxI,KAAK,GAAG,EAAE;EACd;AACF;AACA;EACE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAItG,MAAM,GAAGoH,OAAO,CAAC2H,aAAa;EAClC,IAAIrC,WAAW,GAAGtF,OAAO,CAAC4H,kBAAkB,CAAC,CAAC;;EAE9C,IAAItD,SAAS,GAAG4C,cAAc,CAAC,CAAC,CAAC,CAAC;;EAElC,IAAIW,EAAE,GAAGC,MAAM,CAACC,gBAAgB,CAAC/H,OAAO,CAAC;EACzC,IAAIgI,KAAK,GAAGH,EAAE,CAACI,SAAS;EACxB,IAAIC,QAAQ,GAAGC,UAAU,CAACN,EAAE,CAACK,QAAQ,CAAC;EACtC,IAAIE,aAAa,GAAGF,QAAQ,GAAG,GAAG,CAAC,CAAC;;EAEpC,IAAI1J,QAAQ,CAACM,QAAQ,EAAE;IACrB;IACA;IACA;IACA;IACA4I,UAAU,GAAG;MACXV,IAAI,EAAEhH,OAAO,CAACqI,UAAU;MACxBrC,GAAG,EAAEhG,OAAO,CAACiG,SAAS;MACtBa,KAAK,EAAE9G,OAAO,CAACsI;IACjB,CAAC,CAAC,CAAC;IACH;IACA;;IAEAb,YAAY,GAAGzH,OAAO,CAACsI,WAAW;IAClCd,aAAa,GAAGxH,OAAO,CAACuI,YAAY,CAAC,CAAC;;IAEtCjI,GAAG,CAACN,OAAO,EAAE;MACXwI,QAAQ,EAAExI,OAAO,CAAC8E,KAAK,CAACgC,KAAK;MAC7B2B,SAAS,EAAEzI,OAAO,CAAC8E,KAAK,CAACiC;IAC3B,CAAC,CAAC;EACJ,CAAC,CAAC;;EAGFrH,OAAO,CAAC3G,KAAK,CAAC,CAAC0C,OAAO,CAAC,UAAUzD,IAAI,EAAE;IACrC;IACA,IAAI0Q,UAAU,GAAG1Q,IAAI,CAAC2P,aAAa,KAAK3H,OAAO,CAAC,CAAC;IACjD;;IAEA,IAAI2I,YAAY,GAAG7C,WAAW,CAAC9N,IAAI,EAAE0Q,UAAU,EAAElK,QAAQ,EAAEuH,SAAS,CAAC;MACjEe,KAAK,GAAG6B,YAAY,CAAC7B,KAAK;MAC1BC,MAAM,GAAG4B,YAAY,CAAC5B,MAAM;MAC5Bf,GAAG,GAAG2C,YAAY,CAAC3C,GAAG;MACtBgB,IAAI,GAAG2B,YAAY,CAAC3B,IAAI,CAAC,CAAC;;IAG9B,IAAI,OAAO,CAACnJ,IAAI,CAAC7F,IAAI,CAAC4Q,QAAQ,CAAC,EAAE;IAEjC,IAAInK,KAAK,CAACS,KAAK,IAAIwJ,UAAU,EAAE;MAC7B;MACA;MACA;MACA,IAAInB,WAAW,KAAK,IAAI,IAAIvB,GAAG,GAAGuB,WAAW,IAAIa,aAAa,EAAE;QAC9Db,WAAW,GAAGvB,GAAG;QACjBqB,eAAe,CAAC/L,IAAI,CAACgM,kBAAkB,GAAG,EAAE,CAAC;MAC/C,CAAC,CAAC;;MAGFA,kBAAkB,CAAChM,IAAI,CAACtD,IAAI,CAAC;IAC/B,CAAC,CAAC;;IAGF,IAAIwG,QAAQ,CAACM,QAAQ,EAAE;MACrB;MACAwB,GAAG,CAACtI,IAAI,EAAE;QACRgO,GAAG,EAAEA,GAAG;QACRgB,IAAI,EAAEA,IAAI;QACVF,KAAK,EAAEA,KAAK;QACZC,MAAM,EAAEA;MACV,CAAC,CAAC;IACJ;EACF,CAAC,CAAC,CAAC,CAAC;EACJ;;EAEA,IAAInO,MAAM,EAAE;IACVA,MAAM,CAACH,WAAW,CAACuH,OAAO,CAAC;EAC7B;EACA;AACF;AACA;;EAGE,IAAIvB,KAAK,CAACS,KAAK,EAAE;IACf;IACA;IACA;IACAA,KAAK,GAAGmI,eAAe,CAAC1I,GAAG,CAAC,UAAUkK,eAAe,EAAE;MACrD;MACA,IAAIC,WAAW,GAAGxF,aAAa,CAACa,QAAQ,EAAE;QACxC,OAAO,EAAE,EAAE,CAAClE,MAAM,CAACzB,QAAQ,CAACoF,UAAU,EAAE,GAAG,CAAC,CAAC3D,MAAM,CAACzB,QAAQ,CAACqF,SAAS,CAAC;QACvEiB,KAAK,EAAE,8BAA8B,CAAC7E,MAAM,CAAC+H,KAAK,EAAE,gBAAgB;MACtE,CAAC,CAAC;MACF1H,GAAG,CAACwI,WAAW,EAAE,QAAQ,EAAE,IAAI,CAAC;MAChC,IAAIC,cAAc,GAAG;QACnBhC,MAAM,EAAE,CAAC;QACTf,GAAG,EAAE;MACP,CAAC,CAAC,CAAC;;MAEH1B,SAAS,CAACnM,WAAW,CAAC2Q,WAAW,CAAC,CAAC,CAAC;MACpC;;MAEAD,eAAe,CAACpN,OAAO,CAAC,UAAUuN,aAAa,EAAEvE,GAAG,EAAE5I,GAAG,EAAE;QACzD,IAAIoN,SAAS,GAAGpI,GAAG,CAACmI,aAAa,CAAC;UAC9B9D,SAAS,GAAG+D,SAAS,CAAC/D,SAAS;UAC/Bc,GAAG,GAAGiD,SAAS,CAACjD,GAAG;UACnBe,MAAM,GAAGkC,SAAS,CAAClC,MAAM;QAE7B,IAAI7J,IAAI,GAAGrB,GAAG,CAAC4I,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QACzB;QACA;QACA;QACA;QACA;;QAEAsE,cAAc,CAAChC,MAAM,GAAGmC,IAAI,CAACC,GAAG,CAACJ,cAAc,CAAChC,MAAM,EAAEA,MAAM,CAAC;QAC/DgC,cAAc,CAAC/C,GAAG,GAAGkD,IAAI,CAACE,GAAG,CAACL,cAAc,CAAC/C,GAAG,EAAEA,GAAG,CAAC,CAAC,CAAC;;QAExD8C,WAAW,CAAC3Q,WAAW,CAAC6Q,aAAa,CAAC,CAAC,CAAC;QACxC;QACA;;QAEA,IAAI9D,SAAS,IAAIrE,GAAG,CAAC3D,IAAI,CAAC,CAAC+H,WAAW,EAAE;UACtC6D,WAAW,CAAClR,MAAM,CAAC,GAAG,CAAC;QACzB;MACF,CAAC,CAAC,CAAC,CAAC;;MAEJ,IAAI4G,QAAQ,CAACM,QAAQ,EAAE;QACrBwB,GAAG,CAACwI,WAAW,EAAE;UACf/B,MAAM,EAAEgC,cAAc,CAAChC,MAAM;UAC7Bf,GAAG,EAAE+C,cAAc,CAAC/C;QACtB,CAAC,CAAC;MACJ;MAEA,OAAO8C,WAAW;IACpB,CAAC,CAAC,CAAC,CAAC;;IAEJ,IAAI,CAACrK,KAAK,CAACU,KAAK,EAAE;MAChB8H,YAAY,CAAC3C,SAAS,CAAC;IACzB,CAAC,CAAC;;IAGFtE,OAAO,CAACzH,eAAe,CAAC+L,SAAS,CAAC;EACpC;EACA;AACF;AACA;EACE;EACA;EACA;EACA;;EAGA,IAAI9F,QAAQ,CAACM,QAAQ,EAAE;IACrB;IACA;IACAkB,OAAO,CAAC8E,KAAK,CAACgC,KAAK,GAAG,EAAE,CAAC7G,MAAM,CAACD,OAAO,CAAC8E,KAAK,CAACgC,KAAK,IAAIW,YAAY,EAAE,IAAI,CAAC;IAC1EzH,OAAO,CAAC8E,KAAK,CAACiC,MAAM,GAAG,EAAE,CAAC9G,MAAM,CAACuH,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC;;IAEvD9H,OAAO,CAAC3G,KAAK,CAAC,CAAC0C,OAAO,CAAC,UAAUzD,IAAI,EAAE;MACrC,IAAIqR,UAAU,GAAGxI,GAAG,CAAC7I,IAAI,CAAC;QACtBsR,MAAM,GAAGD,UAAU,CAACC,MAAM;QAC1BtD,GAAG,GAAGqD,UAAU,CAACrD,GAAG;QACpBgB,IAAI,GAAGqC,UAAU,CAACrC,IAAI;QACtBF,KAAK,GAAGuC,UAAU,CAACvC,KAAK;QACxBC,MAAM,GAAGsC,UAAU,CAACtC,MAAM;MAE9B,IAAIwC,UAAU,GAAG1I,GAAG,CAAC7I,IAAI,CAAC2P,aAAa,CAAC;MACxC,IAAI6B,iBAAiB,GAAG,CAACF,MAAM,IAAIC,UAAU,CAACD,MAAM,CAAC,CAAC;MACtD;MACA;;MAEAtR,IAAI,CAAC8M,KAAK,CAACkB,GAAG,GAAG,EAAE,CAAC/F,MAAM,CAACuJ,iBAAiB,GAAGxD,GAAG,GAAGuD,UAAU,CAACvD,GAAG,GAAGA,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;MAClF;MACA;MACA;MACA;;MAEAhO,IAAI,CAAC8M,KAAK,CAACkC,IAAI,GAAGsC,MAAM,GAAG,EAAE,CAACrJ,MAAM,CAACyH,UAAU,CAACV,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC/G,MAAM,CAAC+G,IAAI,IAAIwC,iBAAiB,GAAG9B,UAAU,CAACV,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;;MAEjIhP,IAAI,CAAC8M,KAAK,CAACiC,MAAM,GAAG,EAAE,CAAC9G,MAAM,CAAC8G,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC;MAC7C;;MAEA/O,IAAI,CAAC8M,KAAK,CAACgC,KAAK,GAAGwC,MAAM,GAAG,EAAE,CAACrJ,MAAM,CAACyH,UAAU,CAACZ,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC7G,MAAM,CAAC6G,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;;MAExF9O,IAAI,CAAC8M,KAAK,CAAC/F,QAAQ,GAAG,UAAU;IAClC,CAAC,CAAC;EACJ,CAAC,CAAC;EACF;;EAGA,IAAInG,MAAM,EAAE;IACV,IAAI0M,WAAW,EAAE1M,MAAM,CAACQ,YAAY,CAAC4G,OAAO,EAAEsF,WAAW,CAAC,CAAC,KAAK1M,MAAM,CAACT,WAAW,CAAC6H,OAAO,CAAC;EAC7F;EAEA,OAAOd,KAAK;AACd;AAEA,IAAIuK,SAAS,GAAGzL,MAAM,CAAC2F,QAAQ,EAAE,CAAC,CAAC,CAAC;AAEpC,IAAI+F,SAAS,GAAG,aAAa,YAAY;EACvCnP,YAAY,CAACmP,SAAS,EAAE,IAAI,EAAE,CAAC;IAC7BpP,GAAG,EAAE,WAAW;IAEhB;AACJ;AACA;IACIM,KAAK,EAAE,SAAS+O,SAASA,CAAA,EAAG;MAC1B5I,KAAK,CAAC,CAAC;IACT;IACA;AACJ;AACA;AACA;EAEE,CAAC,EAAE;IACDzG,GAAG,EAAE,aAAa;IAElB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIM,KAAK,EAAE,SAASgP,WAAWA,CAACC,OAAO,EAAE;MACnCJ,SAAS,GAAGzL,MAAM,CAACyL,SAAS,EAAElL,aAAa,CAACsL,OAAO,CAAC,CAAC;MACrD,OAAOlG,QAAQ;IACjB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDrJ,GAAG,EAAE,QAAQ;IACbM,KAAK,EAAE,SAASkP,MAAMA,CAAClK,QAAQ,EAAE;MAC/BD,iBAAiB,CAACC,QAAQ,CAAC,CAACnE,OAAO,CAAC,UAAUuE,OAAO,EAAE;QACrD,IAAIiJ,SAAS,GAAGpI,GAAG,CAACb,OAAO,CAAC;UACxBqB,OAAO,GAAG4H,SAAS,CAAC5H,OAAO;UAC3B0I,IAAI,GAAGd,SAAS,CAACc,IAAI;UACrBvB,QAAQ,GAAGS,SAAS,CAACT,QAAQ;UAC7BC,SAAS,GAAGQ,SAAS,CAACR,SAAS;QAEnC,IAAIpH,OAAO,EAAE;UACXrB,OAAO,CAACgK,SAAS,GAAGD,IAAI;UACxB/J,OAAO,CAAC8E,KAAK,CAACgC,KAAK,GAAG0B,QAAQ,IAAI,EAAE;UACpCxI,OAAO,CAAC8E,KAAK,CAACiC,MAAM,GAAG0B,SAAS,IAAI,EAAE;UACtC3H,MAAM,CAACd,OAAO,CAAC;QACjB;MACF,CAAC,CAAC;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1F,GAAG,EAAE,QAAQ;IACbM,KAAK,EAAE,SAASqP,MAAMA,CAACnQ,MAAM,EAAE+P,OAAO,EAAE;MACtC,OAAO,IAAIH,SAAS,CAAC5P,MAAM,EAAE+P,OAAO,CAAC;IACvC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDvP,GAAG,EAAE,MAAM;IAEX;AACJ;AACA;IACIuG,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,OAAOT,KAAK;IACd;EACF,CAAC,EAAE;IACD9F,GAAG,EAAE,UAAU;IACfuG,GAAG,EAAE,SAASA,GAAGA,CAAA,EAAG;MAClB,OAAO4I,SAAS;IAClB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAXI;;IAaAnJ,GAAG,EAAE,SAASA,GAAGA,CAACuJ,OAAO,EAAE;MACzBJ,SAAS,GAAGzL,MAAM,CAACyL,SAAS,EAAElL,aAAa,CAACsL,OAAO,CAAC,CAAC;IACvD;EACF,CAAC,CAAC,CAAC;EAEH,SAASH,SAASA,CAAC9J,QAAQ,EAAEiK,OAAO,EAAE;IACpCpQ,eAAe,CAAC,IAAI,EAAEiQ,SAAS,CAAC;IAEhC,IAAI,CAACrI,OAAO,GAAG,KAAK;IACpB,IAAI,CAAC7C,QAAQ,GAAGR,MAAM,CAACyL,SAAS,EAAElL,aAAa,CAACsL,OAAO,CAAC,CAAC;IACzD,IAAI,CAACjK,QAAQ,GAAGD,iBAAiB,CAACC,QAAQ,CAAC,CAAC,CAAC;;IAE7C,IAAI,CAAClB,KAAK,CAAC,CAAC;EACd;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGEnE,YAAY,CAACmP,SAAS,EAAE,CAAC;IACvBpP,GAAG,EAAE,OAAO;IACZM,KAAK,EAAE,SAASsP,OAAOA,CAACL,OAAO,EAAE;MAC/B,IAAIM,KAAK,GAAG,IAAI;;MAEhB;MACA;MACA;MACA;MACA,IAAI,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;;MAEf,IAAI,CAAClK,QAAQ,CAACnE,OAAO,CAAC,UAAUuE,OAAO,EAAE;QACvCM,GAAG,CAACN,OAAO,EAAE,MAAM,EAAEA,OAAO,CAACgK,SAAS,CAAC;MACzC,CAAC,CAAC,CAAC,CAAC;;MAEJ,IAAI,CAAC9K,KAAK,GAAG,EAAE;MACf,IAAI,CAACC,KAAK,GAAG,EAAE;MACf,IAAI,CAACC,KAAK,GAAG,EAAE,CAAC,CAAC;;MAEjB,IAAI2G,SAAS,GAAG,CAAC+B,MAAM,CAACsC,WAAW,EAAEtC,MAAM,CAACuC,WAAW,CAAC,CAAC,CAAC;;MAE1D,IAAIR,OAAO,KAAK5R,SAAS,EAAE;QACzB,IAAI,CAACuG,QAAQ,GAAGR,MAAM,CAAC,IAAI,CAACQ,QAAQ,EAAED,aAAa,CAACsL,OAAO,CAAC,CAAC;MAC/D;MAEA,IAAIpL,KAAK,GAAGO,UAAU,CAAC,IAAI,CAACR,QAAQ,CAACC,KAAK,CAAC,CAAC,CAAC;MAC7C;;MAEA,IAAIA,KAAK,CAACQ,IAAI,EAAE;QACd;MACF,CAAC,CAAC;;MAGF,IAAI,CAACW,QAAQ,CAACnE,OAAO,CAAC,UAAUuE,OAAO,EAAE;QACvC;QACA;QACAM,GAAG,CAACN,OAAO,EAAE,QAAQ,EAAE,IAAI,CAAC;QAE5B,IAAIsK,OAAO,GAAG5L,KAAK,CAACsB,OAAO,EAAEmK,KAAK,CAAC3L,QAAQ,CAAC;UACxCW,KAAK,GAAGmL,OAAO,CAACnL,KAAK;UACrBC,KAAK,GAAGkL,OAAO,CAAClL,KAAK;QAEzB+K,KAAK,CAAChL,KAAK,GAAG,EAAE,CAACc,MAAM,CAAC/D,kBAAkB,CAACiO,KAAK,CAAChL,KAAK,CAAC,EAAEjD,kBAAkB,CAACiD,KAAK,CAAC,CAAC;QACnFgL,KAAK,CAAC/K,KAAK,GAAG,EAAE,CAACa,MAAM,CAAC/D,kBAAkB,CAACiO,KAAK,CAAC/K,KAAK,CAAC,EAAElD,kBAAkB,CAACkD,KAAK,CAAC,CAAC;MACrF,CAAC,CAAC;MACF,IAAI,CAACQ,QAAQ,CAACnE,OAAO,CAAC,UAAUuE,OAAO,EAAE;QACvC,IAAIvB,KAAK,CAACS,KAAK,IAAIiL,KAAK,CAAC3L,QAAQ,CAACM,QAAQ,EAAE;UAC1C,IAAII,KAAK,GAAGiI,oBAAoB,CAACnH,OAAO,EAAEmK,KAAK,CAAC3L,QAAQ,EAAEuH,SAAS,CAAC;UACpEoE,KAAK,CAACjL,KAAK,GAAG,EAAE,CAACe,MAAM,CAAC/D,kBAAkB,CAACiO,KAAK,CAACjL,KAAK,CAAC,EAAEhD,kBAAkB,CAACgD,KAAK,CAAC,CAAC;QACrF;MACF,CAAC,CAAC,CAAC,CAAC;;MAEJ,IAAI,CAACmC,OAAO,GAAG,IAAI,CAAC,CAAC;;MAErByG,MAAM,CAACyC,QAAQ,CAACxE,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;MAE7C/E,OAAO,CAAC,CAAC;IACX;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD1G,GAAG,EAAE,QAAQ;IACbM,KAAK,EAAE,SAASkP,MAAMA,CAAA,EAAG;MACvB,IAAI,IAAI,CAACzI,OAAO,EAAE;QAChB;QACA,IAAI,CAACnC,KAAK,GAAG,IAAI;QACjB,IAAI,CAACC,KAAK,GAAG,IAAI;QACjB,IAAI,CAACC,KAAK,GAAG,IAAI;QACjB,IAAI,CAACiC,OAAO,GAAG,KAAK;MACtB;MAEAqI,SAAS,CAACI,MAAM,CAAC,IAAI,CAAClK,QAAQ,CAAC;IACjC;EACF,CAAC,CAAC,CAAC;EAEH,OAAO8J,SAAS;AAClB,CAAC,CAAC,CAAC;AAEH,SAASA,SAAS,IAAIc,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}